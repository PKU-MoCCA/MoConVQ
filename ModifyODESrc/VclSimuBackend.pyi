from typing import Any, ClassVar, Dict, Iterable, List, Optional, Tuple, Union

from typing import overload
#import Common.SmoothOperator
import argparse
import enum
import numpy as np
import numpy
#import pymotionlib.MotionData
import scipy.interpolate._polyint
import typing
AMotorEuler: int
AMotorUser: int
Any: typing._SpecialForm
ContactApprox1: int
ContactSlip1: int
ContactSlip2: int
Dict: typing._SpecialGenericAlias
Infinity: float
Iterable: typing._SpecialGenericAlias
List: typing._SpecialGenericAlias
Optional: typing._SpecialForm
Set: typing._SpecialGenericAlias
Tuple: typing._TupleType
Union: typing._SpecialForm
debug_song: None
environment: None

class AMotor(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def addTorques(self, dRealtorque0, dRealtorque1, dRealtorque2) -> Any: ...
    @overload
    def addTorques(self, torque0, torque1, torque2) -> Any: ...
    @overload
    def getAngle(self, intanum) -> Any: ...
    @overload
    def getAngle(self, anum) -> float: ...
    @overload
    def getAngleRate(self, intanum) -> Any: ...
    @overload
    def getAngleRate(self, anum) -> float: ...
    @overload
    def getAxis(self, intanum) -> Any: ...
    @overload
    def getAxis(self, anum) -> Any: ...
    def getAxisNumpy(self, intanum) -> Any: ...
    @overload
    def getAxisRel(self, intanum) -> Any: ...
    @overload
    def getAxisRel(self, anum) -> int: ...
    @overload
    def getMode(self) -> Any: ...
    @overload
    def getMode(self) -> Any: ...
    @overload
    def getNumAxes(self) -> Any: ...
    @overload
    def getNumAxes(self) -> int: ...
    def getParam(self, intparam) -> Any: ...
    @overload
    def setAngle(self, intanum, dRealangle) -> Any: ...
    @overload
    def setAngle(self, anum, angle) -> Any: ...
    @overload
    def setAxis(self, intanum, intrel, axis) -> Any: ...
    @overload
    def setAxis(self, anum, rel, axis) -> Any: ...
    def setAxisNumpy(self, intanum, intrel, ndarraynp_axis) -> Any: ...
    @overload
    def setMode(self, intmode) -> Any: ...
    @overload
    def setMode(self, mode) -> Any: ...
    @overload
    def setNumAxes(self, intnum) -> Any: ...
    @overload
    def setNumAxes(self, num) -> Any: ...
    def setParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class ArgumentParser(argparse._AttributeHolder, argparse._ActionsContainer):
    __init__: ClassVar[function] = ...
    _add_action: ClassVar[function] = ...
    _check_value: ClassVar[function] = ...
    _get_formatter: ClassVar[function] = ...
    _get_kwargs: ClassVar[function] = ...
    _get_nargs_pattern: ClassVar[function] = ...
    _get_option_tuples: ClassVar[function] = ...
    _get_optional_actions: ClassVar[function] = ...
    _get_positional_actions: ClassVar[function] = ...
    _get_value: ClassVar[function] = ...
    _get_values: ClassVar[function] = ...
    _match_argument: ClassVar[function] = ...
    _match_arguments_partial: ClassVar[function] = ...
    _parse_known_args: ClassVar[function] = ...
    _parse_optional: ClassVar[function] = ...
    _print_message: ClassVar[function] = ...
    _read_args_from_files: ClassVar[function] = ...
    add_subparsers: ClassVar[function] = ...
    convert_arg_line_to_args: ClassVar[function] = ...
    error: ClassVar[function] = ...
    exit: ClassVar[function] = ...
    format_help: ClassVar[function] = ...
    format_usage: ClassVar[function] = ...
    parse_args: ClassVar[function] = ...
    parse_intermixed_args: ClassVar[function] = ...
    parse_known_args: ClassVar[function] = ...
    parse_known_intermixed_args: ClassVar[function] = ...
    print_help: ClassVar[function] = ...
    print_usage: ClassVar[function] = ...

class BallJoint(BallJointBase):
    joint_cfm: Any
    joint_erp: Any
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor1Raw(self) -> Any: ...
    def getAnchor1RawNumpy(self) -> np.ndarray: ...
    def getAnchor2(self) -> Any: ...
    def getAnchor2Numpy(self) -> np.ndarray: ...
    def getAnchor2Raw(self) -> Any: ...
    def getAnchor2RawNumpy(self) -> np.ndarray: ...
    def getAnchorNumpy(self) -> np.ndarray: ...
    def getParam(self, intparam) -> Any: ...
    def get_joint_dof(self) -> int: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    def setAnchorNumpy(self, ndarraynp_pos) -> Any: ...
    def setParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class BallJointAmotor(BallJointBase):
    AMotorMode: Any
    AMotorNumAxis: Any
    AllAxis: Any
    AllAxisRel: Any
    AngleLimit: Any
    Angles: Any
    amotor_cfm: Any
    amotor_erp: Any
    ball_cfm: Any
    ball_erp: Any
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    def _destroy_amotor(self) -> Any: ...
    def _setData(self, value) -> Any: ...
    def addAmotorTorques(self, dRealtorque0, dRealtorque1, dRealtorque2) -> Any: ...
    def attach_ext(self, Bodybody1, Bodybody2) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    def getAmotorAllAxisNumpy(self) -> np.ndarray: ...
    def getAmotorAngle(self, intanum) -> Any: ...
    def getAmotorAngleRate(self, intanum) -> Any: ...
    def getAmotorAngleRateNumpy(self) -> Any: ...
    def getAmotorAxis(self, intanum) -> Any: ...
    def getAmotorAxisNumpy(self, intanum) -> np.ndarray: ...
    def getAmotorAxisRel(self, intanum) -> Any: ...
    def getAmotorMode(self) -> Any: ...
    def getAmotorParam(self, intparam) -> Any: ...
    def getAmtorNumAxes(self) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor1Raw(self) -> Any: ...
    def getAnchor1RawNumpy(self) -> np.ndarray: ...
    def getAnchor2(self) -> Any: ...
    def getAnchor2Numpy(self) -> np.ndarray: ...
    def getAnchor2Raw(self) -> Any: ...
    def getAnchor2RawNumpy(self) -> np.ndarray: ...
    def getAnchorNumpy(self) -> np.ndarray: ...
    def getAngleLimit1(self) -> Any: ...
    def getAngleLimit2(self) -> Any: ...
    def getAngleLimit3(self) -> Any: ...
    def get_amotor_jid(self) -> Any: ...
    def get_joint_dof(self) -> Any: ...
    def setAmotorAngle(self, intanum, dRealangle) -> Any: ...
    def setAmotorAxis(self, intanum, intrel, axis) -> Any: ...
    def setAmotorAxisNumpy(self, intanum, intrel, ndarraynp_axis) -> Any: ...
    def setAmotorMode(self, intmode) -> Any: ...
    def setAmotorNumAxes(self, intnum) -> Any: ...
    def setAmotorParam(self, intparam, dRealvalue) -> Any: ...
    def setAnchor(self, pos) -> Any: ...
    def setAnchorNumpy(self, ndarraynp_pos) -> Any: ...
    def setAngleLim1(self, dReallo, dRealhi) -> Any: ...
    def setAngleLim2(self, dReallo, dRealhi) -> Any: ...
    def setAngleLim3(self, dReallo, dRealhi) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class BallJointBase(Joint):
    joint_cfm: Any
    joint_erp: Any
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Body:
    __hash__: ClassVar[None] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    LinearVelNumpy: Any
    Position: Any
    PositionNumpy: Any
    body_flags: Any
    geom0: Any
    init_inertia: Any
    init_inertia_inv: Any
    instance_id: Any
    isEnabled: bool
    mass_val: Any
    name: Any
    odeAngularVel: Any
    odeForce: Any
    odeLinearVel: Any
    odeRotation: Any
    odeTorque: Any
    offset: Any
    offset_instance_id: Any
    world: Any
    @overload
    def __init__(self, Worldworld) -> Any: ...
    @overload
    def __init__(self, w) -> Any: ...
    def _getBodyData(self) -> Any: ...
    def _getData(self) -> Any: ...
    def _setData(self, data) -> Any: ...
    @overload
    def addForce(self, f) -> Any: ...
    @overload
    def addForce(self, f) -> Any: ...
    @overload
    def addForceAtPos(self, f, p) -> Any: ...
    @overload
    def addForceAtPos(self, f, p) -> Any: ...
    def addForceAtPosNumpy(self, ndarrayf, ndarrayp) -> Any: ...
    @overload
    def addForceAtRelPos(self, f, p) -> Any: ...
    @overload
    def addForceAtRelPos(self, f, p) -> Any: ...
    def addForceNumpy(self, ndarrayf) -> Any: ...
    @overload
    def addRelForce(self, f) -> Any: ...
    @overload
    def addRelForce(self, f) -> Any: ...
    @overload
    def addRelForceAtPos(self, f, p) -> Any: ...
    @overload
    def addRelForceAtPos(self, f, p) -> Any: ...
    @overload
    def addRelForceAtRelPos(self, f, p) -> Any: ...
    @overload
    def addRelForceAtRelPos(self, f, p) -> Any: ...
    @overload
    def addRelTorque(self, t) -> Any: ...
    @overload
    def addRelTorque(self, t) -> Any: ...
    @overload
    def addTorque(self, t) -> Any: ...
    @overload
    def addTorque(self, t) -> Any: ...
    def addTorqueNumpy(self, ndarrayt) -> Any: ...
    def copy_body(self, SpaceBasespace = ...) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    def geom_iter(self) -> Any: ...
    def getAngularVel(self) -> Any: ...
    def getAngularVelNumpy(self) -> Any: ...
    def getFacingInfo(self, Bodyroot_body = ..., intis_vec6d = ...) -> Any: ...
    def getFacingQuaternion(self) -> Any: ...
    def getFacingRotVec(self) -> Any: ...
    def getFacingVec6d(self) -> Any: ...
    def getFiniteRotationAxis(self) -> Any: ...
    def getFiniteRotationMode(self) -> int: ...
    def getForce(self) -> Any: ...
    def getForceNumpy(self) -> Any: ...
    def getGeomIDNumpy(self) -> Any: ...
    @overload
    def getGravityMode(self) -> int: ...
    @overload
    def getGravityMode(self) -> bool: ...
    def getJoint(self, intidx) -> Any: ...
    def getLinearVel(self) -> Any: ...
    @overload
    def getMass(self) -> Mass: ...
    @overload
    def getMass(self) -> mass: ...
    def getNumGeom(self) -> int: ...
    @overload
    def getNumJoints(self) -> Any: ...
    @overload
    def getNumJoints(self) -> int: ...
    def getPointVel(self, p) -> Any: ...
    def getPosRelPoint(self, p) -> Any: ...
    def getPosRelPointNumpy(self, ndarraypos) -> Any: ...
    def getQuaternionScipy(self) -> Any: ...
    def getRelPointPos(self, p) -> Any: ...
    def getRelPointVel(self, p) -> Any: ...
    def getRotation(self) -> Any: ...
    def getRotationAxisAngle(self) -> Any: ...
    def getRotationNumpy(self) -> Any: ...
    def getRotationVec6d(self) -> Any: ...
    def getTorque(self) -> Any: ...
    def getTorqueNumpy(self) -> Any: ...
    def get_aabb(self) -> np.ndarray: ...
    def get_bid(self) -> size_t: ...
    @overload
    def isKinematic(self) -> int: ...
    @overload
    def isKinematic(self) -> bool: ...
    @overload
    def setAngularVel(self, vel) -> Any: ...
    @overload
    def setAngularVel(self, vel) -> Any: ...
    def setAngularVelNumpy(self, ndarrayang_vel) -> Any: ...
    @overload
    def setDynamic(self) -> Any: ...
    @overload
    def setDynamic(self) -> Any: ...
    @overload
    def setFiniteRotationAxis(self, a) -> Any: ...
    @overload
    def setFiniteRotationAxis(self, a) -> Any: ...
    @overload
    def setFiniteRotationMode(self, intmode) -> Any: ...
    @overload
    def setFiniteRotationMode(self, mode) -> Any: ...
    @overload
    def setForce(self, f) -> Any: ...
    @overload
    def setForce(self, f) -> Any: ...
    def setForceNumpy(self, ndarrayf) -> Any: ...
    @overload
    def setGravityMode(self, mode) -> Any: ...
    @overload
    def setGravityMode(self, mode) -> Any: ...
    @overload
    def setKinematic(self) -> Any: ...
    @overload
    def setKinematic(self) -> Any: ...
    @overload
    def setLinearVel(self, vel) -> Any: ...
    @overload
    def setLinearVel(self, vel) -> Any: ...
    @overload
    def setMass(self, Massmass) -> Any: ...
    @overload
    def setMass(self, mass) -> Any: ...
    @overload
    def setMaxAngularSpeed(self, dRealmax_speed) -> Any: ...
    @overload
    def setMaxAngularSpeed(self, max_speed) -> Any: ...
    def setQuaternionScipy(self, ndarrayq) -> Any: ...
    def setRotAndQuatNoNormScipy(self, ndarrayRot, ndarrayquat) -> Any: ...
    @overload
    def setRotationNumpy(self, ndarrayRot) -> Any: ...
    @overload
    def setRotationNumpy(self, Rot) -> Any: ...
    @overload
    def setTorque(self, t) -> Any: ...
    @overload
    def setTorque(self, t) -> Any: ...
    def setTorqueNumpy(self, ndarrayt) -> Any: ...
    def set_draw_local_axis(self, x) -> Any: ...
    def vectorFromWorld(self, v) -> Any: ...
    def vectorToWorld(self, v) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Common:
    class GetFileNameByUI:
        def get_file_name_by_UI(self, initialdir = ..., filetypes = ...) -> Any: ...
        def get_multi_file_name_by_UI(self) -> Any: ...

    class Helper:
        _empty_str_list: ClassVar[list] = ...
        _true_str_list: ClassVar[list] = ...
        def __init__(self) -> Any: ...
        def conf_loader(self, unicodefname: str) -> Dict[str,Any]: ...
        def get_curr_time(self) -> str: ...
        def is_str_empty(self, unicodes: str) -> bool: ...
        def load_numpy_random_state(self, result: Dict[str,Any]) -> None: ...
        def mirror_name_list(self, name_list: List[str]) -> Any: ...
        def print_total_time(self, starttime) -> Any: ...
        def save_numpy_random_state(self) -> Dict[str,Any]: ...
        def set_torch_seed(self, random_seed: int) -> Any: ...
        def str_is_true(self, unicodes: str) -> bool: ...

    class MathHelper:
        unit_vec6d: ClassVar[numpy.ndarray] = ...
        def average_quat_by_slerp(self, qs: List[np.ndarray]) -> np.ndarray: ...
        def axis_decompose(self, ndarrayq: np.ndarray, ndarrayaxis: np.ndarray) -> Any: ...
        def count_ones(self, x: int) -> int: ...
        def cross_mat(self, v) -> Any: ...
        def decompose_rotation(self, ndarrayq: np.ndarray, ndarrayvb: np.ndarray) -> Any: ...
        def ego_forward_vector(self) -> np.ndarray: ...
        def facing_decompose(self, ndarrayq: np.ndarray) -> Tuple[np.ndarray,np.ndarray]: ...
        def flip_quat_arr_by_dot(self, *args) -> List[np.ndarray]: ...
        def flip_quat_arr_by_w(self, *args) -> Any: ...
        def flip_quat_by_dot(self, ndarrayq: np.ndarray, inplace: bool = ...) -> np.ndarray: ...
        def flip_quat_by_w(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def flip_quat_pair_by_dot(self, ndarrayq0s: np.ndarray, ndarrayq1s: np.ndarray) -> Tuple[np.ndarray,np.ndarray]: ...
        def flip_vec3_by_dot(self, ndarrayx: np.ndarray, inplace: bool = ...) -> np.ndarray: ...
        def flip_vector_by_dot(self, ndarrayx: np.ndarray, inplace: bool = ...) -> np.ndarray: ...
        def get_rotation_dim(self, rotate_type) -> Any: ...
        def get_rotation_last_shape(self, rotate_type) -> Tuple: ...
        def normalize_angle(self, ndarraya: np.ndarray) -> np.ndarray: ...
        def normalize_vec(self, ndarraya: np.ndarray) -> np.ndarray: ...
        def np_skew(self, ndarrayv: np.ndarray) -> Any: ...
        def ode_quat_to_rot_mat(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def proj_multi_vec_to_a_plane(self, ndarraya_arr: np.ndarray, ndarrayv: np.ndarray) -> Any: ...
        def quat_between(self, ndarraya: np.ndarray, ndarrayb: np.ndarray) -> np.ndarray: ...
        def quat_equal(self, ndarrayq1: np.ndarray, ndarrayq2: np.ndarray) -> bool: ...
        def quat_from_ode_to_scipy(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def quat_from_ode_to_unity(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def quat_from_other_rotate(self, ndarrayx: np.ndarray, rotate_type) -> np.ndarray: ...
        def quat_from_scipy_to_ode(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def quat_to_other_rotate(self, ndarrayquat: np.ndarray, rotate_type) -> Any: ...
        def rot_mat_to_ode_quat(self, ndarraymat: np.ndarray) -> np.ndarray: ...
        def torch_skew(self, v) -> Any: ...
        def unit_quat(self) -> np.ndarray: ...
        def unit_quat_arr(self, shape: Union[int,Iterable,Tuple[int]]) -> np.ndarray: ...
        def unit_quat_ode(self) -> np.ndarray: ...
        def unit_quat_ode_list(self) -> List[float]: ...
        def unit_quat_scipy(self) -> np.ndarray: ...
        def unit_quat_scipy_list(self) -> List[float]: ...
        def unit_quat_unity(self) -> np.ndarray: ...
        def unit_quat_unity_list(self) -> List[float]: ...
        def unit_vector(self, axis: int) -> np.ndarray: ...
        def up_vector(self) -> np.ndarray: ...
        def vec_axis_to_zero(self, ndarrayv: np.ndarray, axis: Union[int,List[int],np.ndarray]) -> np.ndarray: ...
        def vec_diff(self, ndarrayv_in: np.ndarray, forward: bool, doublefps: float) -> Any: ...
        def wxyz_to_xyzw(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def x_decompose(self, ndarrayq: np.ndarray) -> Tuple[np.ndarray,np.ndarray]: ...
        def xyzw_to_wxyz(self, ndarrayq: np.ndarray) -> np.ndarray: ...
        def y_decompose(self, ndarrayq: np.ndarray) -> Tuple[np.ndarray,np.ndarray]: ...
        def z_decompose(self, ndarrayq: np.ndarray) -> Tuple[np.ndarray,np.ndarray]: ...

    class RotateConvertFast:
        def quat_from_other_rotate(self, ndarrayx: np.ndarray, rotate_type) -> np.ndarray: ...
        def quat_single_from_other_rotate(self, ndarrayx: np.ndarray, rotate_type) -> np.ndarray: ...
        def quat_single_to_other_rotate(self, ndarrayx: np.ndarray, rotate_type) -> np.ndarray: ...
        def quat_to_other_rotate(self, ndarrayx: np.ndarray, rotate_type) -> np.ndarray: ...

    class RotateType(enum.IntEnum):
        class _member_type_:
            denominator: Any
            imag: Any
            numerator: Any
            real: Any
            @classmethod
            def __init__(cls, *args, **kwargs) -> None: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            def bit_count(self) -> Any: ...
            def bit_length(self) -> Any: ...
            def conjugate(self, *args, **kwargs) -> Any: ...
            @classmethod
            def from_bytes(cls, *args, **kwargs) -> Any: ...
            def to_bytes(self, *args, **kwargs) -> Any: ...
            def __abs__(self) -> Any: ...
            def __add__(self, other) -> Any: ...
            def __and__(self, other) -> Any: ...
            def __bool__(self) -> bool: ...
            def __ceil__(self, *args, **kwargs) -> int: ...
            def __divmod__(self, other) -> Any: ...
            def __eq__(self, other) -> bool: ...
            def __float__(self) -> float: ...
            def __floor__(self, *args, **kwargs) -> int: ...
            def __floordiv__(self, other) -> Any: ...
            def __format__(self, *args, **kwargs) -> Any: ...
            def __ge__(self, other) -> bool: ...
            def __getnewargs__(self, *args, **kwargs) -> Any: ...
            def __gt__(self, other) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> Any: ...
            def __int__(self) -> int: ...
            def __invert__(self) -> Any: ...
            def __le__(self, other) -> bool: ...
            def __lshift__(self, other) -> Any: ...
            def __lt__(self, other) -> bool: ...
            def __mod__(self, other) -> Any: ...
            def __mul__(self, other) -> Any: ...
            def __ne__(self, other) -> bool: ...
            def __neg__(self) -> Any: ...
            def __or__(self, other) -> Any: ...
            def __pos__(self) -> Any: ...
            def __pow__(self, other) -> Any: ...
            def __radd__(self, other) -> Any: ...
            def __rand__(self, other) -> Any: ...
            def __rdivmod__(self, other) -> Any: ...
            def __rfloordiv__(self, other) -> Any: ...
            def __rlshift__(self, other) -> Any: ...
            def __rmod__(self, other) -> Any: ...
            def __rmul__(self, other) -> Any: ...
            def __ror__(self, other) -> Any: ...
            def __round__(self) -> Any: ...
            def __rpow__(self, other) -> Any: ...
            def __rrshift__(self, other) -> Any: ...
            def __rshift__(self, other) -> Any: ...
            def __rsub__(self, other) -> Any: ...
            def __rtruediv__(self, other) -> Any: ...
            def __rxor__(self, other) -> Any: ...
            def __sizeof__(self) -> int: ...
            def __sub__(self, other) -> Any: ...
            def __truediv__(self, other) -> Any: ...
            def __trunc__(self) -> int: ...
            def __xor__(self, other) -> Any: ...
        __new__: ClassVar[function] = ...
        AxisAngle: ClassVar[Common.RotateType] = ...
        Matrix: ClassVar[Common.RotateType] = ...
        Quaternion: ClassVar[Common.RotateType] = ...
        SVD9d: ClassVar[Common.RotateType] = ...
        Vec6d: ClassVar[Common.RotateType] = ...
        _generate_next_value_: ClassVar[function] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _value2member_map_: ClassVar[dict] = ...

    class SmoothOperator:
        class ButterWorthBase(Common.SmoothOperator.FilterInfoBase):
            __slots__: ClassVar[tuple] = ...
            order: Any
            wn: Any
            def __init__(self, order: int, doublecut_off_freq: float, sample_freq: int) -> Any: ...
    
        class FilterInfoBase:
            build_from_dict: ClassVar[method] = ...
            __slots__: ClassVar[tuple] = ...
            order: Any
            wn: Any
            def __init__(self, order: int, doublecut_off_freq: float, sample_freq: int) -> Any: ...
            def calc_freq(self, doublecut_off_freq: float, doublesample_freq: float) -> float: ...
    
        class GaussianBase:
            __slots__: ClassVar[tuple] = ...
            width: Any
            def __init__(self, width: Optional[int]) -> Any: ...
    
        class SmoothMode(enum.IntEnum):
            class _member_type_:
                denominator: Any
                imag: Any
                numerator: Any
                real: Any
                @classmethod
                def __init__(cls, *args, **kwargs) -> None: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                def bit_count(self) -> Any: ...
                def bit_length(self) -> Any: ...
                def conjugate(self, *args, **kwargs) -> Any: ...
                @classmethod
                def from_bytes(cls, *args, **kwargs) -> Any: ...
                def to_bytes(self, *args, **kwargs) -> Any: ...
                def __abs__(self) -> Any: ...
                def __add__(self, other) -> Any: ...
                def __and__(self, other) -> Any: ...
                def __bool__(self) -> bool: ...
                def __ceil__(self, *args, **kwargs) -> int: ...
                def __divmod__(self, other) -> Any: ...
                def __eq__(self, other) -> bool: ...
                def __float__(self) -> float: ...
                def __floor__(self, *args, **kwargs) -> int: ...
                def __floordiv__(self, other) -> Any: ...
                def __format__(self, *args, **kwargs) -> Any: ...
                def __ge__(self, other) -> bool: ...
                def __getnewargs__(self, *args, **kwargs) -> Any: ...
                def __gt__(self, other) -> bool: ...
                def __hash__(self) -> int: ...
                def __index__(self) -> Any: ...
                def __int__(self) -> int: ...
                def __invert__(self) -> Any: ...
                def __le__(self, other) -> bool: ...
                def __lshift__(self, other) -> Any: ...
                def __lt__(self, other) -> bool: ...
                def __mod__(self, other) -> Any: ...
                def __mul__(self, other) -> Any: ...
                def __ne__(self, other) -> bool: ...
                def __neg__(self) -> Any: ...
                def __or__(self, other) -> Any: ...
                def __pos__(self) -> Any: ...
                def __pow__(self, other) -> Any: ...
                def __radd__(self, other) -> Any: ...
                def __rand__(self, other) -> Any: ...
                def __rdivmod__(self, other) -> Any: ...
                def __rfloordiv__(self, other) -> Any: ...
                def __rlshift__(self, other) -> Any: ...
                def __rmod__(self, other) -> Any: ...
                def __rmul__(self, other) -> Any: ...
                def __ror__(self, other) -> Any: ...
                def __round__(self) -> Any: ...
                def __rpow__(self, other) -> Any: ...
                def __rrshift__(self, other) -> Any: ...
                def __rshift__(self, other) -> Any: ...
                def __rsub__(self, other) -> Any: ...
                def __rtruediv__(self, other) -> Any: ...
                def __rxor__(self, other) -> Any: ...
                def __sizeof__(self) -> int: ...
                def __sub__(self, other) -> Any: ...
                def __truediv__(self, other) -> Any: ...
                def __trunc__(self) -> int: ...
                def __xor__(self, other) -> Any: ...
            __new__: ClassVar[function] = ...
            BUTTER_WORTH: ClassVar[Common.SmoothOperator.SmoothMode] = ...
            GAUSSIAN: ClassVar[Common.SmoothOperator.SmoothMode] = ...
            NO: ClassVar[Common.SmoothOperator.SmoothMode] = ...
            _generate_next_value_: ClassVar[function] = ...
            _member_map_: ClassVar[dict] = ...
            _member_names_: ClassVar[list] = ...
            _value2member_map_: ClassVar[dict] = ...
        def smooth_operator(self, ndarrayx: np.ndarray, smooth_type) -> np.ndarray: ...

class Contact:
    FDir1: Any
    Motion1: Any
    Motion2: Any
    Slip1: Any
    Slip2: Any
    SoftCFM: Any
    SoftERP: Any
    bounce: Any
    bounceVel: Any
    contactDepth: Any
    contactGeom1: Any
    contactGeom2: Any
    contactNormalNumpy: Any
    contactPosNumpy: Any
    mode: Any
    mu: Any
    mu2: Any
    slip1_enabled: Any
    slip2_enabled: Any
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def enable_contact_slip(self, dRealslip) -> Any: ...
    def enable_soft_cfm_erp(self, dRealcfm, dRealerp) -> Any: ...
    def getContactGeomParams(self) -> Any: ...
    @overload
    def setContactGeomParams(self, ndarraypos, ndarraynormal, dRealdepth, GeomObjectg1 = ..., GeomObjectg2 = ...) -> Any: ...
    @overload
    def setContactGeomParams(self, pos, normal, depth, geom1 = ..., geom2 = ...) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class ContactJoint(ContactJointBase):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup, Contactcontact) -> Any: ...
    @overload
    def __init__(self, world, jointgroup, contact) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class ContactJointBase(Joint):
    bounce: Any
    contact: Any
    contactDepth: Any
    contactGeom1: Any
    contactGeom2: Any
    contactNormalNumpy: Any
    contactPosNumpy: Any
    joint_cfm: Any
    joint_erp: Any
    joint_slip1: Any
    joint_slip2: Any
    mode: Any
    mu: Any
    def __init__(self, *a, **kw) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class ContactJointMaxForce(ContactJointBase):
    def __init__(self, Worldworld, JointGroupjointgroup, Contactcontact) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class DRigidBodyInertiaMode(enum.IntEnum):
    class _member_type_:
        denominator: Any
        imag: Any
        numerator: Any
        real: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        def bit_count(self) -> Any: ...
        def bit_length(self) -> Any: ...
        def conjugate(self, *args, **kwargs) -> Any: ...
        @classmethod
        def from_bytes(cls, *args, **kwargs) -> Any: ...
        def to_bytes(self, *args, **kwargs) -> Any: ...
        def __abs__(self) -> Any: ...
        def __add__(self, other) -> Any: ...
        def __and__(self, other) -> Any: ...
        def __bool__(self) -> bool: ...
        def __ceil__(self, *args, **kwargs) -> int: ...
        def __divmod__(self, other) -> Any: ...
        def __eq__(self, other) -> bool: ...
        def __float__(self) -> float: ...
        def __floor__(self, *args, **kwargs) -> int: ...
        def __floordiv__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> bool: ...
        def __getnewargs__(self, *args, **kwargs) -> Any: ...
        def __gt__(self, other) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Any: ...
        def __le__(self, other) -> bool: ...
        def __lshift__(self, other) -> Any: ...
        def __lt__(self, other) -> bool: ...
        def __mod__(self, other) -> Any: ...
        def __mul__(self, other) -> Any: ...
        def __ne__(self, other) -> bool: ...
        def __neg__(self) -> Any: ...
        def __or__(self, other) -> Any: ...
        def __pos__(self) -> Any: ...
        def __pow__(self, other) -> Any: ...
        def __radd__(self, other) -> Any: ...
        def __rand__(self, other) -> Any: ...
        def __rdivmod__(self, other) -> Any: ...
        def __rfloordiv__(self, other) -> Any: ...
        def __rlshift__(self, other) -> Any: ...
        def __rmod__(self, other) -> Any: ...
        def __rmul__(self, other) -> Any: ...
        def __ror__(self, other) -> Any: ...
        def __round__(self) -> Any: ...
        def __rpow__(self, other) -> Any: ...
        def __rrshift__(self, other) -> Any: ...
        def __rshift__(self, other) -> Any: ...
        def __rsub__(self, other) -> Any: ...
        def __rtruediv__(self, other) -> Any: ...
        def __rxor__(self, other) -> Any: ...
        def __sizeof__(self) -> int: ...
        def __sub__(self, other) -> Any: ...
        def __truediv__(self, other) -> Any: ...
        def __trunc__(self) -> int: ...
        def __xor__(self, other) -> Any: ...
    __new__: ClassVar[function] = ...
    Density: ClassVar[DRigidBodyInertiaMode] = ...
    InertiaValue: ClassVar[DRigidBodyInertiaMode] = ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...

class DRigidBodyMassMode(enum.IntEnum):
    class _member_type_:
        denominator: Any
        imag: Any
        numerator: Any
        real: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        def bit_count(self) -> Any: ...
        def bit_length(self) -> Any: ...
        def conjugate(self, *args, **kwargs) -> Any: ...
        @classmethod
        def from_bytes(cls, *args, **kwargs) -> Any: ...
        def to_bytes(self, *args, **kwargs) -> Any: ...
        def __abs__(self) -> Any: ...
        def __add__(self, other) -> Any: ...
        def __and__(self, other) -> Any: ...
        def __bool__(self) -> bool: ...
        def __ceil__(self, *args, **kwargs) -> int: ...
        def __divmod__(self, other) -> Any: ...
        def __eq__(self, other) -> bool: ...
        def __float__(self) -> float: ...
        def __floor__(self, *args, **kwargs) -> int: ...
        def __floordiv__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> bool: ...
        def __getnewargs__(self, *args, **kwargs) -> Any: ...
        def __gt__(self, other) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Any: ...
        def __le__(self, other) -> bool: ...
        def __lshift__(self, other) -> Any: ...
        def __lt__(self, other) -> bool: ...
        def __mod__(self, other) -> Any: ...
        def __mul__(self, other) -> Any: ...
        def __ne__(self, other) -> bool: ...
        def __neg__(self) -> Any: ...
        def __or__(self, other) -> Any: ...
        def __pos__(self) -> Any: ...
        def __pow__(self, other) -> Any: ...
        def __radd__(self, other) -> Any: ...
        def __rand__(self, other) -> Any: ...
        def __rdivmod__(self, other) -> Any: ...
        def __rfloordiv__(self, other) -> Any: ...
        def __rlshift__(self, other) -> Any: ...
        def __rmod__(self, other) -> Any: ...
        def __rmul__(self, other) -> Any: ...
        def __ror__(self, other) -> Any: ...
        def __round__(self) -> Any: ...
        def __rpow__(self, other) -> Any: ...
        def __rrshift__(self, other) -> Any: ...
        def __rshift__(self, other) -> Any: ...
        def __rsub__(self, other) -> Any: ...
        def __rtruediv__(self, other) -> Any: ...
        def __rxor__(self, other) -> Any: ...
        def __sizeof__(self) -> int: ...
        def __sub__(self, other) -> Any: ...
        def __truediv__(self, other) -> Any: ...
        def __trunc__(self) -> int: ...
        def __xor__(self, other) -> Any: ...
    __new__: ClassVar[function] = ...
    Density: ClassVar[DRigidBodyMassMode] = ...
    MassValue: ClassVar[DRigidBodyMassMode] = ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...

class EmptyBallJoint(Joint):
    def __init__(self, Worldworld) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class FixedJoint(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def setFixed(self) -> Any: ...
    @overload
    def setFixed(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomBox(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    LengthNumpy: Any
    geomLength: Any
    @overload
    def __init__(self, SpaceBasespace = ..., lengths = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., lengths = ...) -> Any: ...
    def getLengthNumpy(self) -> np.ndarray: ...
    def getLengths(self) -> Any: ...
    def placeable(self) -> bool: ...
    @overload
    def pointDepth(self, p) -> Any: ...
    @overload
    def pointDepth(self, p) -> float: ...
    def setLengths(self, lengths) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomCCylinder(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    geomLength: Any
    geomRadiusAndLength: Any
    radius: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def capsule_axis(self) -> Any: ...
    def getParams(self) -> Any: ...
    def placeable(self) -> Any: ...
    @overload
    def pointDepth(self, p) -> Any: ...
    @overload
    def pointDepth(self, p) -> float: ...
    def setParams(self, dRealradius, dReallength) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomCapsule(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    geomLength: Any
    geomRadiusAndLength: Any
    radius: Any
    @overload
    def __init__(self, SpaceBasespace = ..., dRealradius = ..., dReallength = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., radius = ..., length = ...) -> Any: ...
    def capsule_axis(self) -> Any: ...
    def getParams(self) -> Any: ...
    def placeable(self) -> Any: ...
    @overload
    def pointDepth(self, p) -> Any: ...
    @overload
    def pointDepth(self, p) -> float: ...
    def setParams(self, dRealradius, dReallength) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomCylinder(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @overload
    def __init__(self, SpaceBasespace = ..., dRealradius = ..., dReallength = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., radius = ..., length = ...) -> Any: ...
    def getParams(self) -> Any: ...
    def placeable(self) -> Any: ...
    def setParams(self, dRealradius, dReallength) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomObject:
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    AABBNumpy: Any
    CategoryBits: Any
    CollideBits: Any
    PositionNumpy: Any
    QuaternionScipy: Any
    RotationNumpy: Any
    body: Any
    bounce: Any
    character: Any
    character_id: Any
    character_self_collide: Any
    clung_env: Any
    collidable: Any
    friction: Any
    geom_index: Any
    ignore_geom_id: Any
    ignore_geoms: Any
    instance_id: Any
    isEnabled: bool
    isSpace: bool
    is_environment: Any
    max_friction: Any
    name: Any
    render_by_default_color: Any
    render_user_color: Any
    space: Any
    def __init__(self, *a, **kw) -> Any: ...
    def _getData(self) -> Any: ...
    def _setData(self, value) -> Any: ...
    def append_ignore_geom(self, GeomObjectother) -> Any: ...
    @overload
    def clearOffset(self) -> Any: ...
    @overload
    def clearOffset(self) -> Any: ...
    def copy_geom(self, Bodybody, SpaceBasespace) -> Any: ...
    def copy_pos_quat(self, GeomObjectresult) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    def extend_ignore_geom_id(self, listres) -> Any: ...
    def getClass(self) -> int: ...
    def getOffsetPosition(self) -> Any: ...
    def getOffsetPositionNumpy(self) -> Any: ...
    def getOffsetRotation(self) -> Any: ...
    def getOffsetRotationNumpy(self) -> np.ndarray: ...
    def get_gid(self) -> size_t: ...
    @overload
    def placeable(self) -> bool: ...
    @overload
    def placeable(self) -> bool: ...
    @overload
    def setOffsetPosition(self, pos) -> Any: ...
    @overload
    def setOffsetPosition(self, pos) -> Any: ...
    @overload
    def setOffsetRotationNumpy(self, ndarrayrot) -> Any: ...
    @overload
    def setOffsetRotationNumpy(self, R) -> Any: ...
    def setOffsetWorldPositionNumpy(self, ndarraypos) -> Any: ...
    def setOffsetWorldRotationNumpy(self, ndarrayrot) -> Any: ...
    def set_draw_local_axis(self, x) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomPlane(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    odePlaneParam: Any
    odePosition: Any
    @overload
    def __init__(self, SpaceBasespace = ..., normal = ..., dist = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., normal = ..., dist = ...) -> Any: ...
    def getParams(self) -> Any: ...
    @overload
    def pointDepth(self, p) -> Any: ...
    @overload
    def pointDepth(self, p) -> float: ...
    def setParams(self, normal, dist) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomRay(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @overload
    def __init__(self, SpaceBasespace = ..., dRealrlen = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., rlen = ...) -> Any: ...
    def get(self) -> Any: ...
    @overload
    def getLength(self) -> Any: ...
    @overload
    def getLength(self) -> length: ...
    def placeable(self) -> Any: ...
    @overload
    def set(self, p, u) -> Any: ...
    @overload
    def set(self, p, u) -> Any: ...
    @overload
    def setLength(self, rlen) -> Any: ...
    @overload
    def setLength(self, rlen) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomSphere(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    geomRadius: Any
    @overload
    def __init__(self, SpaceBasespace = ..., dRealradius = ...) -> Any: ...
    @overload
    def __init__(self, space = ..., radius = ...) -> Any: ...
    def copy_geom(self, Bodybody, SpaceBasespace) -> Any: ...
    @overload
    def getRadius(self) -> Any: ...
    @overload
    def getRadius(self) -> float: ...
    def placeable(self) -> Any: ...
    @overload
    def pointDepth(self, p) -> Any: ...
    @overload
    def pointDepth(self, p) -> float: ...
    @overload
    def setRadius(self, dRealradius) -> Any: ...
    @overload
    def setRadius(self, radius) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomTransform(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @overload
    def __init__(self, SpaceBasespace = ...) -> Any: ...
    @overload
    def __init__(self, space = ...) -> Any: ...
    @overload
    def getGeom(self) -> Any: ...
    @overload
    def getGeom(self) -> GeomObject: ...
    @overload
    def getInfo(self) -> Any: ...
    @overload
    def getInfo(self) -> int: ...
    def placeable(self) -> Any: ...
    @overload
    def setGeom(self, GeomObjectgeom) -> Any: ...
    @overload
    def setGeom(self, geom) -> Any: ...
    @overload
    def setInfo(self, intmode) -> Any: ...
    @overload
    def setInfo(self, mode) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomTriMesh(GeomObject):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @overload
    def __init__(self, TriMeshDatadata, space = ...) -> Any: ...
    @overload
    def __init__(self, data, space = ...) -> Any: ...
    def _id(self) -> Any: ...
    @overload
    def clearTCCache(self) -> Any: ...
    @overload
    def clearTCCache(self) -> Any: ...
    def getTriangle(self, intidx) -> Any: ...
    @overload
    def getTriangleCount(self) -> Any: ...
    @overload
    def getTriangleCount(self) -> n: ...
    def placeable(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class GeomType:
    def __init__(self) -> Any: ...
    def is_box(self, unicodegeom_type: str) -> Any: ...
    def is_capsule(self, unicodegeom_type: str) -> Any: ...
    def is_plane(self, unicodegeom_type: str) -> Any: ...
    def is_sphere(self, unicodegeom_type: str) -> Any: ...
    @property
    def box_type(self) -> str: ...
    @property
    def capsule_type(self) -> str: ...
    @property
    def plane_type(self) -> str: ...
    @property
    def sphere_type(self) -> str: ...

class GeomTypes:
    Box: ClassVar[int] = ...
    Capsule: ClassVar[int] = ...
    Cylinder: ClassVar[int] = ...
    Plane: ClassVar[int] = ...
    Sphere: ClassVar[int] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class HashSpace(SpaceBase):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, SpaceBasespace = ...) -> Any: ...
    def getLevels(self) -> Any: ...
    @overload
    def setLevels(self, intminlevel, intmaxlevel) -> Any: ...
    @overload
    def setLevels(self, minlevel, maxlevel) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Hinge2Joint(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def addTorques(self, torque1, torque2) -> Any: ...
    @overload
    def addTorques(self, torque1, torque2) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor2(self) -> Any: ...
    @overload
    def getAngle1(self) -> dReal: ...
    @overload
    def getAngle1(self) -> float: ...
    @overload
    def getAngle1Rate(self) -> dReal: ...
    @overload
    def getAngle1Rate(self) -> float: ...
    @overload
    def getAngle2Rate(self) -> dReal: ...
    @overload
    def getAngle2Rate(self) -> float: ...
    def getAxis1(self) -> Any: ...
    def getAxis2(self) -> Any: ...
    def getParam(self, intparam) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    def setParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class HingeJoint(Joint):
    AngleHiStop: Any
    AngleLoStop: Any
    Axis1RawNumpy: Any
    Axis2RawNumpy: Any
    HingeAngle: float
    HingeAngleRate: Any
    HingeAxis: Any
    HingeAxis1: Any
    HingeAxis2: Any
    HingeFlags: Any
    hinge_cfm: Any
    hinge_erp: Any
    hinge_stop_cfm: Any
    joint_cfm: Any
    joint_erp: Any
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def addTorque(self, torque) -> Any: ...
    @overload
    def addTorque(self, torque) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor1Raw(self) -> Any: ...
    def getAnchor1RawNumpy(self) -> Any: ...
    def getAnchor2(self) -> Any: ...
    def getAnchor2Numpy(self) -> Any: ...
    def getAnchor2Raw(self) -> Any: ...
    def getAnchor2RawNumpy(self) -> Any: ...
    def getAnchorNumpy(self) -> np.ndarray: ...
    def getAxis(self) -> Any: ...
    @overload
    def getParam(self, intparam) -> Any: ...
    @overload
    def getParam(self, param) -> float: ...
    def getQRelScipy(self) -> np.ndarray: ...
    def get_joint_dof(self) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    def setAnchorNumpy(self, ndarraynp_pos) -> Any: ...
    def setAngleLimit(self, dReallo, dRealhi) -> Any: ...
    @overload
    def setAxis(self, axis) -> Any: ...
    @overload
    def setAxis(self, axis) -> Any: ...
    @overload
    def setParam(self, intparam, dRealvalue) -> Any: ...
    @overload
    def setParam(self, param, value) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class IO(typing.Generic):
    close: ClassVar[function] = ...
    fileno: ClassVar[function] = ...
    flush: ClassVar[function] = ...
    isatty: ClassVar[function] = ...
    read: ClassVar[function] = ...
    readable: ClassVar[function] = ...
    readline: ClassVar[function] = ...
    readlines: ClassVar[function] = ...
    seek: ClassVar[function] = ...
    seekable: ClassVar[function] = ...
    tell: ClassVar[function] = ...
    truncate: ClassVar[function] = ...
    writable: ClassVar[function] = ...
    write: ClassVar[function] = ...
    writelines: ClassVar[function] = ...
    __enter__: ClassVar[function] = ...
    __exit__: ClassVar[function] = ...
    __orig_bases__: ClassVar[tuple] = ...
    __parameters__: ClassVar[tuple] = ...
    __slots__: ClassVar[tuple] = ...
    @property
    def closed(self) -> Any: ...
    @property
    def mode(self) -> Any: ...
    @property
    def name(self) -> Any: ...

class Inertia:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def RotInertia(self, ndarraynp_rot) -> Any: ...
    def TransInertia(self, dRealtx, dRealty, dRealtz) -> Any: ...
    def TransInertiaNumpy(self, ndarrayt) -> Any: ...
    def add(self, Inertiao) -> Any: ...
    def getI(self) -> Any: ...
    def getMass(self) -> Any: ...
    def setFromMassClass(self, Massm) -> Any: ...
    def setI(self, ndarrayI) -> Any: ...
    def setMass(self, dRealmass) -> Any: ...
    def setMassAndInertia(self, dRealmass, ndarrayI) -> Any: ...
    def toMass(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class IntEnum(int, enum.Enum):
    class _member_type_:
        denominator: Any
        imag: Any
        numerator: Any
        real: Any
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        @overload
        def as_integer_ratio(self) -> Any: ...
        def bit_count(self) -> Any: ...
        def bit_length(self) -> Any: ...
        def conjugate(self, *args, **kwargs) -> Any: ...
        @classmethod
        def from_bytes(cls, *args, **kwargs) -> Any: ...
        def to_bytes(self, *args, **kwargs) -> Any: ...
        def __abs__(self) -> Any: ...
        def __add__(self, other) -> Any: ...
        def __and__(self, other) -> Any: ...
        def __bool__(self) -> bool: ...
        def __ceil__(self, *args, **kwargs) -> int: ...
        def __divmod__(self, other) -> Any: ...
        def __eq__(self, other) -> bool: ...
        def __float__(self) -> float: ...
        def __floor__(self, *args, **kwargs) -> int: ...
        def __floordiv__(self, other) -> Any: ...
        def __format__(self, *args, **kwargs) -> Any: ...
        def __ge__(self, other) -> bool: ...
        def __getnewargs__(self, *args, **kwargs) -> Any: ...
        def __gt__(self, other) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> Any: ...
        def __int__(self) -> int: ...
        def __invert__(self) -> Any: ...
        def __le__(self, other) -> bool: ...
        def __lshift__(self, other) -> Any: ...
        def __lt__(self, other) -> bool: ...
        def __mod__(self, other) -> Any: ...
        def __mul__(self, other) -> Any: ...
        def __ne__(self, other) -> bool: ...
        def __neg__(self) -> Any: ...
        def __or__(self, other) -> Any: ...
        def __pos__(self) -> Any: ...
        def __pow__(self, other) -> Any: ...
        def __radd__(self, other) -> Any: ...
        def __rand__(self, other) -> Any: ...
        def __rdivmod__(self, other) -> Any: ...
        def __rfloordiv__(self, other) -> Any: ...
        def __rlshift__(self, other) -> Any: ...
        def __rmod__(self, other) -> Any: ...
        def __rmul__(self, other) -> Any: ...
        def __ror__(self, other) -> Any: ...
        def __round__(self) -> Any: ...
        def __rpow__(self, other) -> Any: ...
        def __rrshift__(self, other) -> Any: ...
        def __rshift__(self, other) -> Any: ...
        def __rsub__(self, other) -> Any: ...
        def __rtruediv__(self, other) -> Any: ...
        def __rxor__(self, other) -> Any: ...
        def __sizeof__(self) -> int: ...
        def __sub__(self, other) -> Any: ...
        def __truediv__(self, other) -> Any: ...
        def __trunc__(self) -> int: ...
        def __xor__(self, other) -> Any: ...
    __new__: ClassVar[function] = ...
    _generate_next_value_: ClassVar[function] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _value2member_map_: ClassVar[dict] = ...
    __format__: ClassVar[function] = ...

class Joint:
    __hash__: ClassVar[None] = ...
    body1: Any
    body2: Any
    euler_axis: Any
    euler_order: Any
    instance_id: Any
    joint_cfm: Any
    joint_damping: Any
    joint_dof: Any
    joint_erp: Any
    name: Any
    odeAnchor: Any
    odeAnchor2: Any
    world: Any
    def __init__(self, *a, **kw) -> Any: ...
    def FeedBackForce(self) -> np.ndarray: ...
    def _destroyed(self) -> Any: ...
    def _getData(self) -> Any: ...
    def _setData(self, value) -> Any: ...
    @overload
    def attach(self, Bodybody1, Bodybody2) -> Any: ...
    @overload
    def attach(self, body1, body2) -> Any: ...
    def attach_ext(self, Bodybody1, Bodybody2) -> Any: ...
    def dJointGetBody(self, intindex) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    def detach(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    @overload
    def disable(self) -> Any: ...
    def disable_implicit_damping(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    @overload
    def enable(self) -> Any: ...
    def enable_implicit_damping(self) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor2(self) -> Any: ...
    def getAnchor2Numpy(self) -> Any: ...
    def getAnchorNumpy(self) -> Any: ...
    @overload
    def getBody(self, intindex) -> Any: ...
    @overload
    def getBody(self, index) -> Body: ...
    def getFeedback(self) -> Any: ...
    def getKd(self) -> Any: ...
    def getKdNumpy(self) -> np.ndarray: ...
    def getName(self) -> str: ...
    def getNumBodies(self) -> Any: ...
    def getType(self) -> int: ...
    def get_jid(self) -> Any: ...
    def get_joint_dof(self) -> int: ...
    @overload
    def isEnabled(self) -> Any: ...
    @overload
    def isEnabled(self) -> bool: ...
    def pre_clear(self) -> Any: ...
    def setAnchor(self, val) -> Any: ...
    def setAnchorNumpy(self, ndarrayval) -> Any: ...
    @overload
    def setFeedback(self, intflag = ...) -> Any: ...
    @overload
    def setFeedback(self, flag = ...) -> Any: ...
    def setKd(self, dRealkdx, dRealkdy, dRealkdz) -> Any: ...
    def setKd_arrNumpy(self, ndarraykd) -> Any: ...
    def setSameKd(self, dRealkd) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class JointGroup:
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    joints: Any
    @overload
    def __init__(self) -> Any: ...
    @overload
    def __init__(self) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    @overload
    def empty(self) -> Any: ...
    @overload
    def empty(self) -> Any: ...
    def __len__(self) -> int: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class JointParam:
    ParamBounce: ClassVar[int] = ...
    ParamBounce2: ClassVar[int] = ...
    ParamBounce3: ClassVar[int] = ...
    ParamCFM: ClassVar[int] = ...
    ParamCFM2: ClassVar[int] = ...
    ParamCFM3: ClassVar[int] = ...
    ParamFMax: ClassVar[int] = ...
    ParamFMax2: ClassVar[int] = ...
    ParamFMax3: ClassVar[int] = ...
    ParamFudgeFactor: ClassVar[int] = ...
    ParamFudgeFactor2: ClassVar[int] = ...
    ParamFudgeFactor3: ClassVar[int] = ...
    ParamHiStop: ClassVar[int] = ...
    ParamHiStop2: ClassVar[int] = ...
    ParamHiStop3: ClassVar[int] = ...
    ParamLoStop: ClassVar[int] = ...
    ParamLoStop2: ClassVar[int] = ...
    ParamLoStop3: ClassVar[int] = ...
    ParamStopCFM: ClassVar[int] = ...
    ParamStopCFM2: ClassVar[int] = ...
    ParamStopCFM3: ClassVar[int] = ...
    ParamStopERP: ClassVar[int] = ...
    ParamStopERP2: ClassVar[int] = ...
    ParamStopERP3: ClassVar[int] = ...
    ParamSuspensionCFM: ClassVar[int] = ...
    ParamSuspensionCFM2: ClassVar[int] = ...
    ParamSuspensionCFM3: ClassVar[int] = ...
    ParamSuspensionERP: ClassVar[int] = ...
    ParamSuspensionERP2: ClassVar[int] = ...
    ParamSuspensionERP3: ClassVar[int] = ...
    ParamVel: ClassVar[int] = ...
    ParamVel2: ClassVar[int] = ...
    ParamVel3: ClassVar[int] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class JointTypes:
    Amotor: ClassVar[int] = ...
    Ball: ClassVar[int] = ...
    Contact: ClassVar[int] = ...
    Contact2: ClassVar[int] = ...
    Fixed: ClassVar[int] = ...
    Hinge: ClassVar[int] = ...
    Hinge2: ClassVar[int] = ...
    JointNone: ClassVar[int] = ...
    JointNull: ClassVar[int] = ...
    Lmotor: ClassVar[int] = ...
    PR: ClassVar[int] = ...
    PU: ClassVar[int] = ...
    Piston: ClassVar[int] = ...
    Plane2D: ClassVar[int] = ...
    Slider: ClassVar[int] = ...
    Universal: ClassVar[int] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class LMotor(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def getAxis(self, intanum) -> Any: ...
    @overload
    def getAxis(self, anum) -> Any: ...
    def getAxisNumpy(self, intanum) -> Any: ...
    @overload
    def getNumAxes(self) -> Any: ...
    @overload
    def getNumAxes(self) -> int: ...
    def getParam(self, intparam) -> Any: ...
    @overload
    def setAxis(self, intanum, intrel, axis) -> Any: ...
    @overload
    def setAxis(self, anum, rel, axis) -> Any: ...
    def setAxisNumpy(self, intanum, intrel, ndarraynp_axis) -> Any: ...
    @overload
    def setNumAxes(self, intnum) -> Any: ...
    @overload
    def setNumAxes(self, num) -> Any: ...
    def setParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Mass:
    inertia: Any
    mass: Any
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @overload
    def add(self, Massb) -> Any: ...
    @overload
    def add(self, b) -> Any: ...
    @overload
    def adjust(self, dRealnewmass) -> Any: ...
    @overload
    def adjust(self, newmass) -> Any: ...
    def copy(self) -> Any: ...
    def getCNumpy(self) -> Any: ...
    def getINumpy(self) -> np.ndarray: ...
    def rotate(self, R) -> Any: ...
    def rotateNumpy(self, ndarrayRot) -> Any: ...
    @overload
    def setBox(self, dRealdensity, dReallx, dReally, dReallz) -> Any: ...
    @overload
    def setBox(self, density, lx, ly, lz) -> Any: ...
    @overload
    def setBoxTotal(self, dRealtotal_mass, dReallx, dReally, dReallz) -> Any: ...
    @overload
    def setBoxTotal(self, total_mass, lx, ly, lz) -> Any: ...
    @overload
    def setCapsule(self, dRealdensity, intdirection, dRealradius, dReallength) -> Any: ...
    @overload
    def setCapsule(self, density, direction, radius, length) -> Any: ...
    @overload
    def setCapsuleTotal(self, dRealtotal_mass, intdirection, dRealradius, dReallength) -> Any: ...
    @overload
    def setCapsuleTotal(self, total_mass, direction, radius, length) -> Any: ...
    @overload
    def setCylinder(self, dRealdensity, intdirection, dRealr, dRealh) -> Any: ...
    @overload
    def setCylinder(self, density, direction, r, h) -> Any: ...
    @overload
    def setCylinderTotal(self, dRealtotal_mass, intdirection, dRealr, dRealh) -> Any: ...
    @overload
    def setCylinderTotal(self, total_mass, direction, r, h) -> Any: ...
    def setINumpy(self, ndarrayInertia_in) -> Any: ...
    @overload
    def setParameters(self, dRealmass, dRealcgx, dRealcgy, dRealcgz, dRealI11, dRealI22, dRealI33, dRealI12, dRealI13, dRealI23) -> Any: ...
    @overload
    def setParameters(self, mass, cgx, cgy, cgz, I11, I22, I33, I12, I13, I23) -> Any: ...
    @overload
    def setSphere(self, dRealdensity, dRealradius) -> Any: ...
    @overload
    def setSphere(self, density, radius) -> Any: ...
    @overload
    def setSphereTotal(self, dRealtotal_mass, dRealradius) -> Any: ...
    @overload
    def setSphereTotal(self, total_mass, radius) -> Any: ...
    def setTriMesh(self, dRealdensity, GeomObjectg) -> Any: ...
    def setTriMeshTotal(self, dRealtotal_mass, GeomObjectg) -> Any: ...
    @overload
    def setZero(self) -> Any: ...
    @overload
    def setZero(self) -> Any: ...
    @overload
    def translate(self, t) -> Any: ...
    @overload
    def translate(self, t) -> Any: ...
    def __add__(self, other) -> Any: ...
    def __radd__(self, other) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Namespace(argparse._AttributeHolder):
    __init__: ClassVar[function] = ...
    __contains__: ClassVar[function] = ...
    __eq__: ClassVar[function] = ...
    __hash__: ClassVar[None] = ...

class ODESim:
    class BVHToTarget:
        class BVHToTargetBase:
            def __init__(self, bvh_data: Union[str,pymotionlib.MotionData.MotionData], bvh_fps: int, character, ignore_root_xz_pos: bool = ..., bvh_start: Optional[int] = ..., bvh_end: Optional[int] = ..., set_init_state_as_offset: bool = ..., smooth_type: Union[Common.SmoothOperator.GaussianBase,Common.SmoothOperator.ButterWorthBase,None] = ..., flip = ...) -> Any: ...
            def body_names(self) -> List[str]: ...
            def calc_body_posi_by_rot(self, quat, joint_posi) -> Any: ...
            def calc_facing_quat(self, target) -> Any: ...
            def calc_posi_by_rot(self, quat, root_posi) -> Any: ...
            def do_smooth(self, smooth_type: Union[Common.SmoothOperator.GaussianBase,Common.SmoothOperator.ButterWorthBase], test_out_fname: Optional[str] = ...) -> Any: ...
            def init_all_joint_and_body(self, target) -> Any: ...
            def init_end(self, target) -> Any: ...
            def init_facing_coor_end(self, target) -> Any: ...
            def init_facing_root(self, target, ndarrayglobal_lin_vel: np.ndarray, ndarrayglobal_ang_vel: np.ndarray) -> Any: ...
            def init_global_child_body(self, target, vel_forward: bool = ...) -> Any: ...
            def init_locally_coor(self, target, vel_forward: bool = ...) -> Any: ...
            def init_smooth_target(self, target = ..., vel_forward: bool = ...) -> Any: ...
            def init_target(self, target = ..., bvh: Optional[pymotionlib.MotionData.MotionData] = ..., vel_forward: bool = ...) -> Any: ...
            def init_target_global(self, target, vel_forward: bool = ...) -> Any: ...
            def init_target_root(self, target, ndarrayglobal_lin_vel: np.ndarray, ndarrayglobal_ang_vel: np.ndarray) -> Any: ...
            def joint_names(self) -> List[str]: ...
            def only_init_global_target(self, vel_forward: bool = ...) -> Any: ...
            def set_bvh_offset(self, pos_offset: Optional[np.ndarray] = ..., quat_offset: Optional[np.ndarray] = ...) -> Any: ...
            def set_init_state_as_bvh_offset(self) -> Any: ...
            @property
            def bodies(self) -> List[Body]: ...
            @property
            def body_info(self) -> Any: ...
            @property
            def bvh_children(self) -> Any: ...
            @property
            def bvh_joint_cnt(self) -> Any: ...
            @property
            def character_jcnt(self) -> Any: ...
            @property
            def character_to_bvh(self) -> Any: ...
            @property
            def child_body_to_joint(self) -> List[int]: ...
            @property
            def end_joint(self) -> Any: ...
            @property
            def end_to_bvh(self) -> Any: ...
            @property
            def frame_cnt(self) -> Any: ...
            @property
            def has_end_joint(self) -> bool: ...
            @property
            def joint_info(self) -> Any: ...
            @property
            def joint_to_child_body(self) -> List[int]: ...
            @property
            def joint_to_parent_body(self) -> List[int]: ...
            @property
            def joints(self) -> List[Union[Joint,BallJoint,BallJointAmotor,HingeJoint]]: ...
            @property
            def root_joint(self) -> Optional[Joint]: ...
            @property
            def space(self) -> SpaceBase: ...
            @property
            def world(self) -> World: ...

    class BodyInfo:
        class BodyInfo:
            __slots__: ClassVar[tuple] = ...
            bodies: Any
            body_c_id: Any
            children: Any
            initial_inertia: Any
            mass_val: Any
            parent: Any
            root_body_id: Any
            space: Any
            sum_mass: Any
            visualize_color: Any
            world: Any
            def __init__(self, Worldworld: World, SpaceBasespace: SpaceBase) -> Any: ...
            def add_body_force(self, ndarrayforce: np.ndarray) -> Any: ...
            def add_body_torque(self, ndarraytorque: np.ndarray) -> Any: ...
            def calc_angular_momentum_slow(self) -> Tuple[np.ndarray,Inertia]: ...
            def calc_body_c_id(self) -> np.ndarray: ...
            def calc_body_init_inertia(self) -> np.ndarray: ...
            def calc_body_init_inertia_inv(self) -> np.ndarray: ...
            def calc_center_of_mass(self) -> np.ndarray: ...
            def calc_com_and_facing_com_by_body_state(self, state) -> Tuple[np.ndarray,np.ndarray]: ...
            def calc_com_by_body_state(self, state) -> np.ndarray: ...
            def calc_facing_com_by_body_state(self, state) -> np.ndarray: ...
            def calc_facing_quat(self) -> np.ndarray: ...
            def calc_geom_ignore_id(self, ignore_parent_collision: bool = ..., ignore_grandpa_collision: bool = ...) -> Any: ...
            def calc_momentum(self) -> np.ndarray: ...
            def calc_sum_mass_pos(self) -> np.ndarray: ...
            def calc_velo_com(self) -> np.ndarray: ...
            def clear(self) -> Any: ...
            def get_aabb(self) -> np.ndarray: ...
            def get_body_ang_velo(self) -> np.ndarray: ...
            def get_body_angvel_at(self, index: int) -> np.ndarray: ...
            def get_body_contact_mu(self) -> np.ndarray: ...
            def get_body_force(self) -> np.ndarray: ...
            def get_body_inertia(self) -> np.ndarray: ...
            def get_body_pos(self) -> np.ndarray: ...
            def get_body_pos_at(self, index: int) -> np.ndarray: ...
            def get_body_quat(self) -> np.ndarray: ...
            def get_body_quat_at(self, index: int) -> np.ndarray: ...
            def get_body_rot(self) -> np.ndarray: ...
            def get_body_rot_mat_at(self, index: int) -> np.ndarray: ...
            def get_body_torque(self) -> np.ndarray: ...
            def get_body_velo(self) -> np.ndarray: ...
            def get_body_velo_at(self, index: int) -> np.ndarray: ...
            def get_geom_pos(self) -> Any: ...
            def get_geom_rot(self) -> Any: ...
            def get_mirror_index(self) -> List[int]: ...
            def get_name_list(self) -> List[str]: ...
            def get_relative_global_pos(self) -> np.ndarray: ...
            def get_subset(self, remain_body_index: List[int] = ...) -> Any: ...
            def init_after_load(self, ignore_parent_collision: bool = ..., ignore_grandpa_collision: bool = ...) -> Any: ...
            def set_body_ang_velo(self, ndarrayomega: np.ndarray) -> Any: ...
            def set_body_pos(self, ndarraypos: np.ndarray) -> Any: ...
            def set_body_quat(self, ndarrayquat: np.ndarray) -> Any: ...
            def set_body_quat_rot(self, ndarrayquat: np.ndarray, ndarrayrot: np.ndarray) -> Any: ...
            def set_body_velo(self, ndarrayvelo: np.ndarray) -> Any: ...
            def __len__(self) -> int: ...
            @property
            def body0(self) -> Optional[Body]: ...
            @property
            def body1(self) -> Optional[Body]: ...
            @property
            def root_body(self) -> Body: ...
        def my_concatenate(self, tup: Iterable[np.ndarray], axis = ...) -> Any: ...

    class BodyInfoState:
        class BodyInfoState:
            __slots__: ClassVar[tuple] = ...
            angular_vel: Any
            force: Any
            linear_vel: Any
            pd_target: Any
            pos: Any
            quat: Any
            rot: Any
            torque: Any
            def __init__(self) -> Any: ...
            def calc_delta(self, o) -> Any: ...
            def cat_to_ndarray(self) -> np.ndarray: ...
            def check_delta(self, o) -> Any: ...
            def check_failed(self) -> bool: ...
            def clear(self) -> Any: ...
            def copy(self) -> Any: ...
            def is_empty(self) -> Any: ...
            def load(self, Worldworld: World, ndarraybody_c_id: np.ndarray) -> Any: ...
            def reshape(self) -> Any: ...
            def save(self, Worldworld: World, ndarraybody_c_id: np.ndarray) -> Any: ...
            def set_value(self, ndarraypos: np.ndarray, ndarrayrot: np.ndarray, ndarrayquat: np.ndarray, ndarraylinvel: np.ndarray, ndarrayangvel: np.ndarray, pd_target: Optional[np.ndarray]) -> Any: ...
            def to_continuous(self) -> Any: ...
            def __del__(self) -> Any: ...
            def __len__(self) -> Any: ...

    class CharacterJointInfoRoot(ODESim.CharacterWrapper):
        def __init__(self, character) -> Any: ...
        def get_joint_dof(self) -> np.ndarray: ...
        def get_parent_body_index(self) -> np.ndarray: ...
        def get_parent_joint_dof(self) -> np.ndarray: ...
        def get_parent_joint_euler_axis(self) -> np.ndarray: ...
        def get_parent_joint_euler_order(self) -> List[str]: ...
        def get_parent_joint_pos(self) -> np.ndarray: ...

    class CharacterTOBVH:
        def __init__(self, character, sim_fps: int = ...) -> Any: ...
        def append_no_root_to_buffer(self) -> Any: ...
        def append_with_root_to_buffer(self) -> Any: ...
        def build_hierarchy(self) -> Any: ...
        def build_hierarchy_base(self) -> Any: ...
        def build_hierarchy_with_root(self) -> Any: ...
        def bvh_append_no_root(self) -> Any: ...
        def bvh_append_with_root(self) -> Any: ...
        def bvh_hierarchy_no_root(self) -> Any: ...
        def deepcopy(self) -> Any: ...
        def forward_kinematics(self, ndarrayroot_pos: np.ndarray, ndarrayroot_quat: np.ndarray, ndarrayjoint_local_quat: np.ndarray) -> pymotionlib.MotionData.MotionData: ...
        def insert_end_site(self, motion: Optional[pymotionlib.MotionData.MotionData] = ...) -> Any: ...
        def merge_buf(self) -> Any: ...
        def ret_merge_buf(self) -> pymotionlib.MotionData.MotionData: ...
        def to_file(self, unicodefname: str = ..., print_info = ...) -> pymotionlib.MotionData.MotionData: ...
        @property
        def root_idx(self) -> Any: ...

    class CharacterWrapper:
        def __init__(self, character = ...) -> Any: ...
        def body_names(self) -> List[str]: ...
        def joint_names(self) -> List[str]: ...
        @property
        def bodies(self) -> List[Body]: ...
        @property
        def body_info(self) -> Any: ...
        @property
        def child_body_to_joint(self) -> List[int]: ...
        @property
        def end_joint(self) -> Any: ...
        @property
        def has_end_joint(self) -> bool: ...
        @property
        def joint_info(self) -> Any: ...
        @property
        def joint_to_child_body(self) -> List[int]: ...
        @property
        def joint_to_parent_body(self) -> List[int]: ...
        @property
        def joints(self) -> List[Union[Joint,BallJoint,BallJointAmotor,HingeJoint]]: ...
        @property
        def root_joint(self) -> Optional[Joint]: ...
        @property
        def space(self) -> SpaceBase: ...
        @property
        def world(self) -> World: ...

    class EndJointInfo:
        class EndJointInfo:
            def __init__(self, Worldworld: World) -> Any: ...
            def clear(self) -> Any: ...
            def get_global_pos(self) -> np.ndarray: ...
            def resize(self) -> Any: ...
            def __len__(self) -> int: ...

    class Environment:
        class Environment:
            def __init__(self, Worldworld: World, SpaceBasespace: SpaceBase) -> Any: ...
            def clear(self) -> Any: ...
            def create_floor(self, friction = ...) -> GeomPlane: ...
            def disable(self) -> Any: ...
            def enable(self) -> Any: ...
            def get_floor_in_list(self) -> Optional[GeomObject]: ...
            def set_space(self, space: Optional[SpaceBase]) -> SpaceBase: ...
            def __len__(self) -> int: ...

    class ExtJointList:
        class ExtJointInfo:
            def __init__(self, character0_id: int = ..., body0_id: int = ..., character1_id: int = ..., body1_id: int = ...) -> Any: ...

    class JointInfo:
        class JointInfos(ODESim.JointInfo.JointInfosBase):
            def __init__(self, Worldworld: World) -> Any: ...
            def body_rotvec(self, Bodybody: Body) -> np.ndarray: ...
            def child_qs(self) -> np.ndarray: ...
            def clear(self) -> Any: ...
            def disable_root(self) -> None: ...
            def enable_root(self) -> None: ...
            def gen_sample_mask(self, use_joint_names = ...) -> np.ndarray: ...
            def get_adj_matrix(self) -> np.ndarray: ...
            def get_ball_erp(self, balls: Optional[List[Union[BallJoint,BallJointAmotor]]] = ...) -> np.ndarray: ...
            def get_cfm(self) -> np.ndarray: ...
            def get_child_body_relative_pos(self) -> np.ndarray: ...
            def get_erp(self) -> np.ndarray: ...
            def get_global_anchor1(self) -> np.ndarray: ...
            def get_global_anchor2(self) -> np.ndarray: ...
            def get_global_angvels(self) -> np.ndarray: ...
            def get_global_pos1(self) -> np.ndarray: ...
            def get_global_pos2(self) -> np.ndarray: ...
            def get_hinge_angle(self) -> np.ndarray: ...
            def get_hinge_axis1(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_axis2(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_erp(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_hi(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_lo(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_raw_axis1(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_hinge_raw_axis2(self, hinges: Optional[List[HingeJoint]] = ...) -> np.ndarray: ...
            def get_joint_euler_order(self) -> List[str]: ...
            def get_local_angvels(self, parent_qs_inv: Optional[np.ndarray] = ...) -> np.ndarray: ...
            def get_local_q(self) -> np.ndarray: ...
            def get_mirror_index(self) -> List[int]: ...
            def get_neighbours(self) -> List[List[int]]: ...
            def get_parent_body_relative_pos(self) -> np.ndarray: ...
            def get_parent_child_qs(self) -> Tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray]: ...
            def get_parent_child_qs_old(self) -> Tuple[np.ndarray,np.ndarray,np.ndarray,np.ndarray]: ...
            def get_relative_global_pos(self) -> np.ndarray: ...
            def get_relative_local_pos(self) -> Tuple[np.ndarray,np.ndarray]: ...
            def get_subset(self, remain_joint_index: List[int]) -> Any: ...
            def get_subset_by_name(self, remain_joint_names: List[str]) -> Any: ...
            def parent_qs(self) -> np.ndarray: ...
            def resize_euler_axis_local(self) -> Any: ...
            def set_joint_weights(self, weight_dict: Dict[str,float]) -> Any: ...
            @property
            def root_joint(self) -> Optional[Joint]: ...
    
        class JointInfosBase:
            def __init__(self, Worldworld: World) -> Any: ...
            def ball_id(self) -> List[int]: ...
            def ball_joints(self) -> List[Union[BallJointAmotor,BallJoint]]: ...
            def clear(self) -> Any: ...
            def has_hinge(self) -> bool: ...
            def hinge_id(self) -> List[int]: ...
            def hinge_joints(self) -> List[HingeJoint]: ...
            def hinge_lo_hi(self) -> Tuple[Optional[np.ndarray],Optional[np.ndarray]]: ...
            def joint_names(self) -> List[str]: ...
            def __add__(self, other) -> Any: ...
            def __len__(self) -> int: ...
        def my_concatenate(self, tup, axis = ...) -> np.ndarray: ...

    class JointInfoInit:
        class JointInfoInit:
            euler_axis_local: Optional[np.ndarray]
            joints: List[Joint]
            def __init__(self, joint_info) -> Any: ...
            def calc_joint_c_id(self) -> Any: ...
            def init_after_load(self) -> Any: ...
            def joint_names(self) -> List[str]: ...
            def set_ball_joint_limit(self, BallJointAmotorjoint: BallJointAmotor, unicodeeuler_order: str, angle_limits: Union[List,np.ndarray], raw_axis: Optional[np.ndarray] = ...) -> Any: ...
            def __len__(self) -> int: ...
            @property
            def kds(self) -> Optional[np.ndarray]: ...
            @property
            def kps(self) -> Optional[np.ndarray]: ...
            @property
            def pa_joint_id(self) -> List[int]: ...
            @property
            def world(self) -> World: ...

    class JointInfoWrapper:
        class JointInfoWrapper:
            euler_axis_local: Optional[np.ndarray]
            joints: List[Joint]
            def __init__(self, joint_info = ...) -> Any: ...
            def joint_names(self) -> List[str]: ...
            def __len__(self) -> int: ...
            @property
            def kds(self) -> Optional[np.ndarray]: ...
            @property
            def kps(self) -> Optional[np.ndarray]: ...
            @property
            def pa_joint_id(self) -> List[int]: ...
            @property
            def world(self) -> World: ...

    class JsonCharacterLoader:
        def __init__(self, Worldworld: World, space: Space, use_hinge: bool = ..., use_angle_limit: bool = ..., ignore_parent_collision: bool = ..., ignore_grandpa_collision: bool = ..., doubleload_scale: float = ..., use_as_base_class: bool = ...) -> Any: ...
        def add_body(self, json_body: Dict[str,Any], update_body_pos_by_com: bool = ...) -> Body: ...
        def add_joint(self, json_joint: Dict[str,Any], load_hinge: bool = ..., load_limits: bool = ...) -> Joint: ...
        def body_names(self) -> List[str]: ...
        def calc_hinge_axis(self, unicodeeuler_order: str, axis_mat: Optional[np.ndarray] = ...) -> np.ndarray: ...
        def create_geom_object(self, json_geom: Dict[str,Any], calc_mass: bool = ..., doubledefault_density: float = ..., friction: Optional[float] = ...) -> Tuple[GeomObject,Optional[Mass]]: ...
        def create_joint(self, json_joint: Dict[str,Any], load_hinge: bool = ..., load_limits: bool = ...) -> Joint: ...
        def create_joint_base(self, Worldworld: World, json_joint: Dict[str,Any], load_hinge: bool = ..., use_ball_limit: bool = ...) -> Any: ...
        def joint_attach(self, Jointjoint: Joint, joint_pos, joint_parent: int, joint_child: int) -> Any: ...
        def joint_names(self) -> List[str]: ...
        def load(self, mess_dict: Dict[str,Any]) -> Any: ...
        def load_bodies(self, json_bodies: List, update_body_pos_by_com: bool = ...) -> Any: ...
        def load_endjoints(self, json_endjoints: List) -> Any: ...
        def load_from_file(self, unicodefname: str) -> Any: ...
        def load_init_root_info(self, init_root_param: Dict[str,Any]) -> Any: ...
        def load_joints(self, json_joints: List) -> Any: ...
        def load_pd_control_param(self, json_pd_param: Dict[str,Any]) -> Any: ...
        def parse_ignore_list(self) -> Any: ...
        def post_create_joint(self, joint: Union[BallJointAmotor,HingeJoint,BallJoint,FixedJoint], json_joint: Dict[str,Any], load_limits: bool = ...) -> Any: ...
        def set_ball_limit(self, BallJointAmotorjoint: BallJointAmotor, unicodeeuler_order: str, angle_limits: Union[List,np.ndarray], raw_axis: Optional[np.ndarray] = ...) -> Any: ...
        def set_character(self, character = ...) -> Any: ...
        @property
        def bodies(self) -> List[Body]: ...
        @property
        def body_info(self) -> Any: ...
        @property
        def child_body_to_joint(self) -> List[int]: ...
        @property
        def end_joint(self) -> Any: ...
        @property
        def has_end_joint(self) -> bool: ...
        @property
        def joint_info(self) -> Any: ...
        @property
        def joint_to_child_body(self) -> List[int]: ...
        @property
        def joint_to_parent_body(self) -> List[int]: ...
        @property
        def joints(self) -> List[Union[Joint,BallJoint,BallJointAmotor,HingeJoint]]: ...
        @property
        def root_joint(self) -> Optional[Joint]: ...

    class JsonSceneLoader:
        class AdditionalConfig:
            def __init__(self) -> Any: ...
            def update_config_dict(self, mess: Optional[Dict[str,Any]]) -> Dict[str,Any]: ...
        def __init__(self, scene = ..., is_running: bool = ...) -> Any: ...
        def file_load(self, unicodefname: str, config = ...) -> Any: ...
        def load_character_list(self, mess_dict: Dict[str,Any]) -> Any: ...
        def load_environment(self, mess_dict: Dict[str,Any]) -> Any: ...
        def load_ext_forces(self, mess_dict: Dict[str,Any]) -> Any: ...
        def load_ext_joints(self, mess_dict: Dict[str,Any]) -> Any: ...
        def load_from_file(self, unicodefname: str, config = ...) -> Any: ...
        def load_from_pickle_file(self, unicodefname: str, config = ...) -> Any: ...
        def load_json(self, mess_dict: Dict[str,Any], config: Optional[AdditionalConfig] = ...) -> Any: ...
        def load_world_attr(self, mess_dict: Dict[str,Any]) -> Any: ...
        @property
        def character0(self) -> Any: ...
        @property
        def characters(self) -> Any: ...
        @property
        def environment(self) -> Any: ...
        @property
        def ext_joints(self) -> Any: ...
        @property
        def space(self) -> SpaceBase: ...
        @property
        def world(self) -> World: ...

    class MeshCharacterLoader:
        def __init__(self, Worldworld: World, SpaceBasespace: SpaceBase) -> Any: ...
        def load_from_obj(self, obj_path, meshname, volume_scale = ..., density_scale = ..., inverse_xaxis = ...) -> Any: ...

    class MessDictScale:
        def handle_dict(self, mess_dict: Dict[str,Any], doubleload_scale: float) -> Any: ...
        def handle_list(self, mess_list: List, doubleload_scale: float) -> Any: ...
        def handle_value(self, key, value, doublescale: float) -> Any: ...

    class ODECharacter:
        class DRootInitInfo:
            def __init__(self) -> None: ...
            def clear(self) -> Any: ...
    
        class ODECharacter:
            is_enable: bool
            is_kinematic: bool
            self_collision: bool
            def __init__(self, Worldworld: World, SpaceBasespace: SpaceBase) -> Any: ...
            def calc_kinetic_energy(self) -> np.ndarray: ...
            def cat_root_child_body_value(self, ndarrayroot_value: np.ndarray, ndarraychild_body_value: np.ndarray, dtype = ...) -> Any: ...
            def character_facing_coor_com(self, facing_rot_inv: Optional[np.ndarray] = ..., com: Optional[np.ndarray] = ...) -> np.ndarray: ...
            def character_facing_coor_com_old(self, facing_rot_inv: Union[Rotation,np.ndarray,None] = ...) -> np.ndarray: ...
            def character_facing_coor_com_velo(self) -> np.ndarray: ...
            def character_facing_coor_end_pos(self, facing_rot_inv: Optional[np.ndarray] = ...) -> np.ndarray: ...
            def character_facing_coor_end_pos_old(self, facing_rot_inv: Union[Rotation,np.ndarray,None] = ...) -> np.ndarray: ...
            def character_facing_coord_angular_momentum(self) -> np.ndarray: ...
            def check_root(self) -> Any: ...
            def clear(self) -> Any: ...
            def disable_all_clung_env(self) -> None: ...
            def enable_all_clung_env(self) -> None: ...
            def get_aabb(self) -> np.ndarray: ...
            def get_body_ang_velo(self) -> np.ndarray: ...
            def get_body_angvel_at(self, index: int) -> np.ndarray: ...
            def get_body_mat(self) -> np.ndarray: ...
            def get_body_name_list(self) -> List[str]: ...
            def get_body_pos(self) -> np.ndarray: ...
            def get_body_pos_at(self, index: int) -> np.ndarray: ...
            def get_body_quat(self) -> np.ndarray: ...
            def get_body_quat_at(self, index: int) -> np.ndarray: ...
            def get_body_rot_mat_at(self, index: int) -> np.ndarray: ...
            def get_body_velo(self) -> np.ndarray: ...
            def get_body_velo_at(self, index: int) -> np.ndarray: ...
            def get_joint_names(self, with_root: bool = ...) -> List[str]: ...
            def get_raw_anchor(self) -> Tuple[np.ndarray,np.ndarray]: ...
            def init_root_body_pos(self) -> np.ndarray: ...
            def init_root_quat(self) -> np.ndarray: ...
            def load(self, body_state) -> Any: ...
            def load_init_state(self) -> None: ...
            def move_character(self, ndarraynew_pos: np.ndarray) -> None: ...
            def move_character_by_delta(self, ndarraydelta_pos: np.ndarray) -> None: ...
            def rotate_body_info_state_y_axis(self, state, doubleangle: float, use_delta_angle: bool = ...) -> Any: ...
            def rotate_character(self) -> Any: ...
            def rotate_y_axis(self, doubleangle: float, use_delta_angle: bool = ...) -> Any: ...
            def save(self) -> Any: ...
            def save_init_state(self) -> Any: ...
            def set_body_ang_velo(self, ndarrayang_velo: np.ndarray) -> Any: ...
            def set_body_pos(self, ndarraypos: np.ndarray) -> Any: ...
            def set_body_velo(self, ndarrayvelo: np.ndarray) -> Any: ...
            def set_character_id(self, new_id: int) -> Any: ...
            def set_clung_env(self, body_names: Iterable[str], value: bool = ...) -> Any: ...
            def set_geom_max_friction(self, doublecoef: float = ...) -> None: ...
            def set_ode_space(self, space: Optional[SpaceBase]) -> Any: ...
            def set_render_color(self, ndarraycolor: np.ndarray) -> Any: ...
            def set_root_pos(self, ndarraypos: np.ndarray) -> Any: ...
            @property
            def bodies(self) -> List[Body]: ...
            @property
            def end_joint_weights(self) -> Optional[np.ndarray]: ...
            @property
            def has_end_joint(self) -> bool: ...
            @property
            def joint_weights(self) -> Optional[np.ndarray]: ...
            @property
            def joints(self) -> List[Joint]: ...
            @property
            def root_body(self) -> Body: ...
            @property
            def root_body_pos(self) -> np.ndarray: ...
            @property
            def root_body_quat(self) -> np.ndarray: ...
            @property
            def root_joint(self) -> Optional[Joint]: ...

    class ODECharacterInit(ODESim.CharacterWrapper):
        def __init__(self, character) -> Any: ...
        def add_root_joint(self) -> Any: ...
        def append_body(self, Bodybody: Body, Massmass_total: Mass, unicodename: str, parent: Optional[int]) -> Any: ...
        def calc_height(self) -> Any: ...
        def calc_joint_child_body_c_id(self) -> Any: ...
        def calc_joint_parent_body_c_id(self) -> Any: ...
        def calc_joint_parent_idx(self) -> Any: ...
        def calc_map_body_joint(self) -> Any: ...
        def compute_geom_mass_attr(self, Bodybody: Body, create_geom: List[GeomObject], gmasses: List[Mass], gcenters: List, grots: List[Rotation], update_body_pos_by_com: bool = ...) -> Any: ...
        def init_after_load(self, character_id: int = ..., ignore_parent_collision: bool = ..., ignore_grandpa_collision: bool = ...) -> Any: ...
        def init_end_joint(self, names: List[str], parent_body_ids: List[int], ndarrayend_pos: np.ndarray) -> Any: ...
        def init_end_joint_pa_joint_id(self, init_c_id: bool = ...) -> Any: ...
        def set_geom_character_id(self, character_id: int = ...) -> Any: ...
        def set_geom_index(self) -> Any: ...
        def set_geom_max_friction(self, doublecoef: float = ...) -> Any: ...
        def set_has_root(self) -> Any: ...

    class ODEScene:
        class ContactType(enum.IntEnum):
            class _member_type_:
                denominator: Any
                imag: Any
                numerator: Any
                real: Any
                @classmethod
                def __init__(cls, *args, **kwargs) -> None: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                def bit_count(self) -> Any: ...
                def bit_length(self) -> Any: ...
                def conjugate(self, *args, **kwargs) -> Any: ...
                @classmethod
                def from_bytes(cls, *args, **kwargs) -> Any: ...
                def to_bytes(self, *args, **kwargs) -> Any: ...
                def __abs__(self) -> Any: ...
                def __add__(self, other) -> Any: ...
                def __and__(self, other) -> Any: ...
                def __bool__(self) -> bool: ...
                def __ceil__(self, *args, **kwargs) -> int: ...
                def __divmod__(self, other) -> Any: ...
                def __eq__(self, other) -> bool: ...
                def __float__(self) -> float: ...
                def __floor__(self, *args, **kwargs) -> int: ...
                def __floordiv__(self, other) -> Any: ...
                def __format__(self, *args, **kwargs) -> Any: ...
                def __ge__(self, other) -> bool: ...
                def __getnewargs__(self, *args, **kwargs) -> Any: ...
                def __gt__(self, other) -> bool: ...
                def __hash__(self) -> int: ...
                def __index__(self) -> Any: ...
                def __int__(self) -> int: ...
                def __invert__(self) -> Any: ...
                def __le__(self, other) -> bool: ...
                def __lshift__(self, other) -> Any: ...
                def __lt__(self, other) -> bool: ...
                def __mod__(self, other) -> Any: ...
                def __mul__(self, other) -> Any: ...
                def __ne__(self, other) -> bool: ...
                def __neg__(self) -> Any: ...
                def __or__(self, other) -> Any: ...
                def __pos__(self) -> Any: ...
                def __pow__(self, other) -> Any: ...
                def __radd__(self, other) -> Any: ...
                def __rand__(self, other) -> Any: ...
                def __rdivmod__(self, other) -> Any: ...
                def __rfloordiv__(self, other) -> Any: ...
                def __rlshift__(self, other) -> Any: ...
                def __rmod__(self, other) -> Any: ...
                def __rmul__(self, other) -> Any: ...
                def __ror__(self, other) -> Any: ...
                def __round__(self) -> Any: ...
                def __rpow__(self, other) -> Any: ...
                def __rrshift__(self, other) -> Any: ...
                def __rshift__(self, other) -> Any: ...
                def __rsub__(self, other) -> Any: ...
                def __rtruediv__(self, other) -> Any: ...
                def __rxor__(self, other) -> Any: ...
                def __sizeof__(self) -> int: ...
                def __sub__(self, other) -> Any: ...
                def __truediv__(self, other) -> Any: ...
                def __trunc__(self) -> int: ...
                def __xor__(self, other) -> Any: ...
            __new__: ClassVar[function] = ...
            BALL: ClassVar[ODESim.ODEScene.ContactType] = ...
            MAX_FORCE_ODE_LCP: ClassVar[ODESim.ODEScene.ContactType] = ...
            ODE_LCP: ClassVar[ODESim.ODEScene.ContactType] = ...
            _generate_next_value_: ClassVar[function] = ...
            _member_map_: ClassVar[dict] = ...
            _member_names_: ClassVar[list] = ...
            _value2member_map_: ClassVar[dict] = ...
    
        class ODEScene:
            default_gravity: ClassVar[list] = ...
            contact_count: int
            self_collision: bool
            soft_cfm: Any
            soft_erp: Any
            use_soft_contact: Any
            def __init__(self, render_fps: int = ..., sim_fps: int = ..., gravity: Union[Iterable,float,None] = ..., doublefriction: float = ..., doublebounce: float = ..., self_collision: bool = ..., contact_type = ..., contact_count: int = ..., extract_contact: bool = ..., hand_scene: bool = ...) -> Any: ...
            def _compute_collide_callback(self, args, GeomObjectgeom1: GeomObject, GeomObjectgeom2: GeomObject) -> Any: ...
            def _generate_contact_joint(self, GeomObjectgeom1: GeomObject, GeomObjectgeom2: GeomObject, contacts: List[Contact]) -> Any: ...
            def build_world_and_space(self, gravity: Union[Iterable,float,None] = ...) -> Any: ...
            def clear(self, gravity: Union[Iterable,float,None] = ...) -> Any: ...
            def compute_collide_info(self) -> Any: ...
            def contact_basic(self, GeomObjectgeom1: GeomObject, GeomObjectgeom2: GeomObject) -> Optional[List[Contact]]: ...
            def contact_local_save(self) -> Any: ...
            def contact_save(self) -> Any: ...
            def create_floor(self) -> GeomPlane: ...
            def damped_simulate(self, n: int = ...) -> Any: ...
            def damped_simulate_no_collision(self, n: int = ...) -> Any: ...
            def damped_simulate_no_collision_once(self) -> Any: ...
            def damped_simulate_once(self) -> Any: ...
            def damped_step_fast_collision(self) -> Any: ...
            def disable_implicit_damping(self) -> Any: ...
            def extract_body_contact_label(self) -> np.ndarray: ...
            def fast_simulate_once(self) -> Any: ...
            def get_character_id_map(self) -> Any: ...
            def near_callback(self, args, GeomObjectgeom1: GeomObject, GeomObjectgeom2: GeomObject) -> Any: ...
            def post_simulate_step(self) -> Any: ...
            def pre_simulate_step(self) -> JointGroup: ...
            def reset(self) -> Any: ...
            def resort_geoms(self) -> Any: ...
            def set_falldown_flag(self, GeomObjectgeom1: GeomObject, GeomObjectgeom2: GeomObject) -> Any: ...
            def set_gravity(self, gravity: Union[Iterable,float,None] = ...) -> Any: ...
            def set_render_fps(self, render_fps: int) -> Any: ...
            def set_sim_fps(self, sim_fps: int) -> Any: ...
            def set_simulation_type(self, sim_type) -> Any: ...
            def simulate(self, n: int = ...) -> Any: ...
            def simulate_no_collision(self, n: int = ...) -> Any: ...
            def simulate_once(self) -> Any: ...
            def step_fast_collision(self) -> Any: ...
            def step_range(self) -> range: ...
            def use_implicit_damping(self) -> Any: ...
            @property
            def character0(self) -> Any: ...
            @property
            def floor(self) -> Optional[GeomPlane]: ...
            @property
            def gravity_numpy(self) -> np.ndarray: ...
    
        class SceneContactInfo:
            __slots__: ClassVar[tuple] = ...
            body1_index: Any
            body2_index: Any
            body_contact_force: Any
            contact_label: Any
            force: Any
            geom1_name: Any
            geom2_name: Any
            pos: Any
            torque: Any
            def __init__(self, pos: Union[np.ndarray,List,None] = ..., force: Union[np.ndarray,List,None] = ..., geom1_name: Optional[List[str]] = ..., geom2_name: Optional[List[str]] = ..., contact_label: Union[np.ndarray,List[float],None] = ..., body_contact_force: Union[np.ndarray,None] = ...) -> Any: ...
            def check_delta(self, other) -> Any: ...
            def clear(self) -> Any: ...
            def merge_force_by_body1(self) -> Any: ...
            def out_iter(self) -> Any: ...
            def set_value(self, pos: Optional[np.ndarray], force: Optional[np.ndarray], geom1_name: Optional[List[str]], geom2_name: Optional[List[str]], contact_label: Union[np.ndarray,List[float],None] = ..., body_contact_force: Union[np.ndarray,None] = ...) -> Any: ...
            def __len__(self) -> int: ...
    
        class SceneContactLocalInfo:
            def __init__(self) -> None: ...
            def clear(self) -> Any: ...
            def get_global_pos(self, Worldworld: World) -> np.ndarray: ...
            def set_value(self, ndarrayglobal_pos: np.ndarray, ndarraylocal_pos: np.ndarray, ndarraynormal: np.ndarray, ndarraydepth: np.ndarray, ndarraybody1_cid: np.ndarray, to_continuous: bool = ...) -> Any: ...
    
        class SimulationType(enum.IntEnum):
            class _member_type_:
                denominator: Any
                imag: Any
                numerator: Any
                real: Any
                @classmethod
                def __init__(cls, *args, **kwargs) -> None: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                @overload
                def as_integer_ratio(self) -> Any: ...
                def bit_count(self) -> Any: ...
                def bit_length(self) -> Any: ...
                def conjugate(self, *args, **kwargs) -> Any: ...
                @classmethod
                def from_bytes(cls, *args, **kwargs) -> Any: ...
                def to_bytes(self, *args, **kwargs) -> Any: ...
                def __abs__(self) -> Any: ...
                def __add__(self, other) -> Any: ...
                def __and__(self, other) -> Any: ...
                def __bool__(self) -> bool: ...
                def __ceil__(self, *args, **kwargs) -> int: ...
                def __divmod__(self, other) -> Any: ...
                def __eq__(self, other) -> bool: ...
                def __float__(self) -> float: ...
                def __floor__(self, *args, **kwargs) -> int: ...
                def __floordiv__(self, other) -> Any: ...
                def __format__(self, *args, **kwargs) -> Any: ...
                def __ge__(self, other) -> bool: ...
                def __getnewargs__(self, *args, **kwargs) -> Any: ...
                def __gt__(self, other) -> bool: ...
                def __hash__(self) -> int: ...
                def __index__(self) -> Any: ...
                def __int__(self) -> int: ...
                def __invert__(self) -> Any: ...
                def __le__(self, other) -> bool: ...
                def __lshift__(self, other) -> Any: ...
                def __lt__(self, other) -> bool: ...
                def __mod__(self, other) -> Any: ...
                def __mul__(self, other) -> Any: ...
                def __ne__(self, other) -> bool: ...
                def __neg__(self) -> Any: ...
                def __or__(self, other) -> Any: ...
                def __pos__(self) -> Any: ...
                def __pow__(self, other) -> Any: ...
                def __radd__(self, other) -> Any: ...
                def __rand__(self, other) -> Any: ...
                def __rdivmod__(self, other) -> Any: ...
                def __rfloordiv__(self, other) -> Any: ...
                def __rlshift__(self, other) -> Any: ...
                def __rmod__(self, other) -> Any: ...
                def __rmul__(self, other) -> Any: ...
                def __ror__(self, other) -> Any: ...
                def __round__(self) -> Any: ...
                def __rpow__(self, other) -> Any: ...
                def __rrshift__(self, other) -> Any: ...
                def __rshift__(self, other) -> Any: ...
                def __rsub__(self, other) -> Any: ...
                def __rtruediv__(self, other) -> Any: ...
                def __rxor__(self, other) -> Any: ...
                def __sizeof__(self) -> int: ...
                def __sub__(self, other) -> Any: ...
                def __truediv__(self, other) -> Any: ...
                def __trunc__(self) -> int: ...
                def __xor__(self, other) -> Any: ...
            __new__: ClassVar[function] = ...
            DAMPED_FAST_STEP: ClassVar[ODESim.ODEScene.SimulationType] = ...
            DAMPED_STEP: ClassVar[ODESim.ODEScene.SimulationType] = ...
            FAST_STEP: ClassVar[ODESim.ODEScene.SimulationType] = ...
            STEP: ClassVar[ODESim.ODEScene.SimulationType] = ...
            _generate_next_value_: ClassVar[function] = ...
            _member_map_: ClassVar[dict] = ...
            _member_names_: ClassVar[list] = ...
            _value2member_map_: ClassVar[dict] = ...

    class PDController:
        class DampedPDControler:
            def __init__(self, character) -> Any: ...
            def add_torques_by_quat(self, ndarraytar_local_qs: np.ndarray) -> np.ndarray: ...
    
        class DampedPDControlerSlow(ODESim.PDController.PDControlerBase):
            def __init__(self, joint_info) -> Any: ...
            def add_torques_by_quat(self, ndarraytar_local_qs: np.ndarray) -> np.ndarray: ...
    
        class PDControler(ODESim.PDController.PDControlerBase):
            def __init__(self, joint_info) -> Any: ...
            def add_torques_by_quat(self, ndarraytar_local_qs: np.ndarray) -> np.ndarray: ...
    
        class PDControlerBase:
            def __init__(self, joint_info) -> Any: ...
            def _add_clipped_torque(self, ndarrayparent_qs: np.ndarray, ndarraylocal_torques: np.ndarray) -> np.ndarray: ...
            def _add_local_torque(self, ndarrayparent_qs: np.ndarray, ndarraylocal_torques: np.ndarray) -> np.ndarray: ...
            def add_torques_by_quat(self, ndarraytar_local_qs: np.ndarray) -> np.ndarray: ...

    class TargetPose:
        class SetTargetToCharacter:
            def __init__(self, character, target) -> Any: ...
            def body_names(self) -> List[str]: ...
            def check(self, frame: int) -> Any: ...
            def joint_names(self) -> List[str]: ...
            def set_character_byframe(self, frame: int = ..., other_character = ...) -> Any: ...
            def set_character_byframe_old(self, frame: int = ..., other_character = ...) -> Any: ...
            @property
            def bodies(self) -> List[Body]: ...
            @property
            def body_info(self) -> Any: ...
            @property
            def child_body_to_joint(self) -> List[int]: ...
            @property
            def end_joint(self) -> Any: ...
            @property
            def has_end_joint(self) -> bool: ...
            @property
            def joint_info(self) -> Any: ...
            @property
            def joint_to_child_body(self) -> List[int]: ...
            @property
            def joint_to_parent_body(self) -> List[int]: ...
            @property
            def joints(self) -> List[Union[Joint,BallJoint,BallJointAmotor,HingeJoint]]: ...
            @property
            def num_frames(self) -> Any: ...
            @property
            def root_joint(self) -> Optional[Joint]: ...
            @property
            def space(self) -> SpaceBase: ...
            @property
            def world(self) -> World: ...
    
        class TargetBaseType:
            __slots__: ClassVar[tuple] = ...
            angacc: Any
            angvel: Any
            linacc: Any
            linvel: Any
            pos: Any
            quat: Any
            rot_mat: Any
            def __init__(self) -> Any: ...
            def append(self, other) -> Any: ...
            def deepcopy(self) -> Any: ...
            def duplicate(self, times: int = ...) -> Any: ...
            def resize(self, shape: Union[int,Iterable,Tuple[int]], dtype = ...) -> Any: ...
            def set_value(self, pos: Optional[np.ndarray] = ..., quat: Optional[np.ndarray] = ..., rot_mat: Optional[np.ndarray] = ..., linvel: Optional[np.ndarray] = ..., angvel: Optional[np.ndarray] = ..., linacc: Optional[np.ndarray] = ..., angacc: Optional[np.ndarray] = ...) -> Any: ...
            def sub_seq(self, start: int = ..., end: Optional[int] = ..., skip: Optional[int] = ..., is_copy: bool = ...) -> Any: ...
            def to_continuous(self) -> Any: ...
            def __len__(self) -> int: ...
    
        class TargetPose:
            __slots__: ClassVar[tuple] = ...
            all_child_body: Any
            all_joint_facing: Any
            all_joint_global: Any
            all_joint_local: Any
            character_body: Any
            child_body: Any
            dup_pos_off_mix: Any
            dup_root_pos: Any
            dup_root_quat: Any
            dup_rot_off_mix: Any
            end: Any
            facing_coor_end: Any
            facing_quat: Any
            facing_root: Any
            fps: Any
            globally: Any
            locally: Any
            num_frames: Any
            root: Any
            root_body: Any
            smoothed: Any
            def __init__(self) -> Any: ...
            def append(self, other) -> Any: ...
            def compute_global_root_dup(self, dup_count: int) -> Any: ...
            def compute_global_root_dup_impl(self, dup_count: int, pos_off_mix: Optional[np.ndarray], rot_off_mix: Union[np.ndarray,Rotation,None]) -> Any: ...
            def deepcopy(self) -> Any: ...
            def duplicate(self, times: int = ...) -> Any: ...
            def get_facing_body_info(self) -> Any: ...
            def set_dup_off_mix(self, ndarraypos_off_mix: np.ndarray, rot_off_mix: Union[np.ndarray,Rotation]) -> Any: ...
            def sub_seq(self, start: Optional[int] = ..., end_: Optional[int] = ..., skip: Optional[int] = ..., is_copy: bool = ...) -> Any: ...
            def to_continuous(self) -> Any: ...
            def __len__(self) -> int: ...

    class Utils:
        class BVHJointMap:
            def __init__(self, bvh: pymotionlib.MotionData.MotionData, character) -> Any: ...
            def body_names(self) -> List[str]: ...
            def joint_names(self) -> List[str]: ...
            @property
            def bodies(self) -> List[Body]: ...
            @property
            def body_info(self) -> Any: ...
            @property
            def bvh_joint_cnt(self) -> Any: ...
            @property
            def child_body_to_joint(self) -> List[int]: ...
            @property
            def end_joint(self) -> Any: ...
            @property
            def has_end_joint(self) -> bool: ...
            @property
            def joint_info(self) -> Any: ...
            @property
            def joint_to_child_body(self) -> List[int]: ...
            @property
            def joint_to_parent_body(self) -> List[int]: ...
            @property
            def joints(self) -> List[Union[Joint,BallJoint,BallJointAmotor,HingeJoint]]: ...
            @property
            def root_joint(self) -> Optional[Joint]: ...
            @property
            def space(self) -> SpaceBase: ...
            @property
            def world(self) -> World: ...

class PRJoint(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def getAnchor(self) -> Any: ...
    @overload
    def getAnchor(self) -> Any: ...
    @overload
    def getAxis1(self) -> Any: ...
    @overload
    def getAxis1(self) -> Any: ...
    @overload
    def getAxis2(self) -> Any: ...
    @overload
    def getAxis2(self) -> Any: ...
    @overload
    def getPosition(self) -> Any: ...
    @overload
    def getPosition(self) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Plane2DJoint(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    def setAngleParam(self, intparam, dRealvalue) -> Any: ...
    def setXParam(self, intparam, dRealvalue) -> Any: ...
    def setYParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class PyEigenArrayXXd:
    def __init__(self, ndarraya) -> Any: ...
    def ToNumpy(self) -> np.ndarray: ...
    def size(self) -> int: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class PyEigenArrayXd:
    def __init__(self, ndarraya) -> Any: ...
    def ToNumpy(self) -> np.ndarray: ...
    def size(self) -> int: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class PyEigenMatrixXd:
    def __init__(self, ndarraya) -> Any: ...
    def ToNumpy(self) -> np.ndarray: ...
    def cols(self) -> int: ...
    def rows(self) -> int: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class PyEigenVectorXd:
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, ndarraya) -> Any: ...
    def ToNumpy(self) -> np.ndarray: ...
    def size(self) -> int: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class QuadTreeSpace(SpaceBase):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, center, extents, depth, SpaceBasespace = ...) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class R:
    single: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def _as_euler_from_matrix(self, seq, degrees = ...) -> Any: ...
    def _compute_euler(self, seq, degrees, algorithm) -> Any: ...
    @classmethod
    def align_vectors(cls, typecls, a, b, weights = ..., return_sensitivity = ...) -> Any: ...
    @overload
    def apply(self, vectors, inverse = ...) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors, inverse = ...) -> Any: ...
    def as_euler(self, seq, degrees = ...) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_quat(self, canonical = ...) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self, canonical = ...) -> Any: ...
    @overload
    def as_rotvec(self, degrees = ...) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self, degrees = ...) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @classmethod
    def concatenate(cls, typecls, rotations) -> Any: ...
    @classmethod
    def create_group(cls, typecls, group, axis = ...) -> Any: ...
    @classmethod
    def from_euler(cls, typecls, seq, angles, degrees = ...) -> Any: ...
    @overload
    @classmethod
    def from_matrix(cls, typecls, matrix) -> Any: ...
    @overload
    @classmethod
    def from_matrix(cls, a) -> Any: ...
    @classmethod
    def from_mrp(cls, typecls, mrp) -> Any: ...
    @classmethod
    def from_quat(cls, typecls, quat) -> Any: ...
    @classmethod
    def from_rotvec(cls, typecls, rotvec, degrees = ...) -> Any: ...
    @classmethod
    def identity(cls, typecls, num = ...) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def magnitude(self, s) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def mean(self, weights = ...) -> Any: ...
    @overload
    def mean(self) -> Any: ...
    @overload
    @classmethod
    def random(cls, typecls, num = ..., random_state = ...) -> Any: ...
    @overload
    @classmethod
    def random(cls) -> Any: ...
    def reduce(self, left = ..., right = ..., return_indices = ...) -> Any: ...
    def __bool__(self) -> bool: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, other) -> Any: ...
    def __reduce_cython__(self, *args, **kwargs) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...
    def __setstate__(self, state) -> Any: ...
    def __setstate_cython__(self, *args, **kwargs) -> Any: ...

class Render:
    class RenderWorld:
        def __init__(self, myworld) -> Any: ...
        def check_wid(self) -> Any: ...
        def draw_background(self, x) -> Any: ...
        def draw_hingeaxis(self, x) -> Any: ...
        def draw_localaxis(self, x) -> Any: ...
        def get_screen_buffer(self) -> Any: ...
        def kill(self) -> Any: ...
        def look_at(self, pos, target, up) -> Any: ...
        def pause(self, time_) -> Any: ...
        def set_axis_length(self, x) -> Any: ...
        def set_color(self, col) -> Any: ...
        def set_joint_radius(self, r) -> Any: ...
        def start(self) -> Any: ...
        def start_record_video(self) -> Any: ...
        def track_body(self, body, sync_y) -> Any: ...

class Rotation:
    single: Any
    def __init__(self, *args, **kwargs) -> None: ...
    def _as_euler_from_matrix(self, seq, degrees = ...) -> Any: ...
    def _compute_euler(self, seq, degrees, algorithm) -> Any: ...
    @classmethod
    def align_vectors(cls, typecls, a, b, weights = ..., return_sensitivity = ...) -> Any: ...
    @overload
    def apply(self, vectors, inverse = ...) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vector) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors) -> Any: ...
    @overload
    def apply(self, vectors, inverse = ...) -> Any: ...
    def as_euler(self, seq, degrees = ...) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_matrix(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_mrp(self) -> Any: ...
    @overload
    def as_quat(self, canonical = ...) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self) -> Any: ...
    @overload
    def as_quat(self, canonical = ...) -> Any: ...
    @overload
    def as_rotvec(self, degrees = ...) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self, degrees = ...) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @overload
    def as_rotvec(self) -> Any: ...
    @classmethod
    def concatenate(cls, typecls, rotations) -> Any: ...
    @classmethod
    def create_group(cls, typecls, group, axis = ...) -> Any: ...
    @classmethod
    def from_euler(cls, typecls, seq, angles, degrees = ...) -> Any: ...
    @overload
    @classmethod
    def from_matrix(cls, typecls, matrix) -> Any: ...
    @overload
    @classmethod
    def from_matrix(cls, a) -> Any: ...
    @classmethod
    def from_mrp(cls, typecls, mrp) -> Any: ...
    @classmethod
    def from_quat(cls, typecls, quat) -> Any: ...
    @classmethod
    def from_rotvec(cls, typecls, rotvec, degrees = ...) -> Any: ...
    @classmethod
    def identity(cls, typecls, num = ...) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def inv(self) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def magnitude(self, s) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def magnitude(self) -> Any: ...
    @overload
    def mean(self, weights = ...) -> Any: ...
    @overload
    def mean(self) -> Any: ...
    @overload
    @classmethod
    def random(cls, typecls, num = ..., random_state = ...) -> Any: ...
    @overload
    @classmethod
    def random(cls) -> Any: ...
    def reduce(self, left = ..., right = ..., return_indices = ...) -> Any: ...
    def __bool__(self) -> bool: ...
    def __delitem__(self, other) -> Any: ...
    def __getitem__(self, index) -> Any: ...
    def __getstate__(self) -> Any: ...
    def __len__(self) -> int: ...
    def __mul__(self, other) -> Any: ...
    def __reduce_cython__(self, *args, **kwargs) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __setitem__(self, index, object) -> None: ...
    def __setstate__(self, state) -> Any: ...
    def __setstate_cython__(self, *args, **kwargs) -> Any: ...

class SimpleSpace(SpaceBase):
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    def __init__(self, SpaceBasespace = ...) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class SliderJoint(Joint):
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def addForce(self, force) -> Any: ...
    @overload
    def addForce(self, force) -> Any: ...
    def getAxis(self) -> Any: ...
    def getParam(self, param) -> Any: ...
    @overload
    def getPosition(self) -> Any: ...
    @overload
    def getPosition(self) -> float: ...
    @overload
    def getPositionRate(self) -> Any: ...
    @overload
    def getPositionRate(self) -> float: ...
    @overload
    def setAxis(self, axis) -> Any: ...
    @overload
    def setAxis(self, axis) -> Any: ...
    def setParam(self, param, value) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class SpaceBase(GeomObject):
    __hash__: ClassVar[None] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    NumGeoms: Any
    def __init__(self, *a, **kw) -> Any: ...
    def ResortGeoms(self) -> Any: ...
    def _getData(self) -> Any: ...
    def _setData(self, value) -> Any: ...
    @overload
    def add(self, GeomObjectgeom) -> Any: ...
    @overload
    def add(self, geom) -> Any: ...
    @overload
    def collide(self, arg, callback) -> Any: ...
    @overload
    def collide(self, arg, callback) -> Any: ...
    @overload
    def collide(self) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    def getAllGeomInfos(self, with_scale_flag = ..., with_name_flag = ...) -> Any: ...
    def getAllGeomName(self) -> Any: ...
    @overload
    def getGeom(self, intidx) -> GeomObject: ...
    @overload
    def getGeom(self, idx) -> GeomObject: ...
    def getGeomIDs(self) -> np.ndarray: ...
    def getPlaceableCount(self) -> Any: ...
    def getPlaceableGeomInfos(self) -> Any: ...
    def get_bodies_aabb(self, ndarraynp_id) -> Any: ...
    def get_sid(self) -> Any: ...
    @overload
    def query(self, GeomObjectgeom) -> bool: ...
    @overload
    def query(self, geom) -> bool: ...
    @overload
    def remove(self, GeomObjectgeom) -> Any: ...
    @overload
    def remove(self, geom) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __iter__(self) -> Any: ...
    def __le__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class TriMeshData:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @overload
    def build(self, verts, faces) -> Any: ...
    @overload
    def build(self, verts, faces) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class UniversalJoint(Joint):
    @overload
    def __init__(self, Worldworld, JointGroupjointgroup = ...) -> Any: ...
    @overload
    def __init__(self, world, jointgroup = ...) -> Any: ...
    @overload
    def addTorques(self, torque1, torque2) -> Any: ...
    @overload
    def addTorques(self, torque1, torque2) -> Any: ...
    def getAnchor(self) -> Any: ...
    def getAnchor2(self) -> Any: ...
    def getAngle1(self) -> Any: ...
    def getAngle1Rate(self) -> Any: ...
    def getAngle2(self) -> Any: ...
    def getAngle2Rate(self) -> Any: ...
    def getAxis1(self) -> Any: ...
    def getAxis2(self) -> Any: ...
    def getParam(self, intparam) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAnchor(self, pos) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis1(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    @overload
    def setAxis2(self, axis) -> Any: ...
    def setParam(self, intparam, dRealvalue) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class Utils:
    class InvDynAttr:
        def __init__(self, ref_start: int, ref_end: int) -> None: ...

    class MergeMode(enum.IntEnum):
        class _member_type_:
            denominator: Any
            imag: Any
            numerator: Any
            real: Any
            @classmethod
            def __init__(cls, *args, **kwargs) -> None: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            def bit_count(self) -> Any: ...
            def bit_length(self) -> Any: ...
            def conjugate(self, *args, **kwargs) -> Any: ...
            @classmethod
            def from_bytes(cls, *args, **kwargs) -> Any: ...
            def to_bytes(self, *args, **kwargs) -> Any: ...
            def __abs__(self) -> Any: ...
            def __add__(self, other) -> Any: ...
            def __and__(self, other) -> Any: ...
            def __bool__(self) -> bool: ...
            def __ceil__(self, *args, **kwargs) -> int: ...
            def __divmod__(self, other) -> Any: ...
            def __eq__(self, other) -> bool: ...
            def __float__(self) -> float: ...
            def __floor__(self, *args, **kwargs) -> int: ...
            def __floordiv__(self, other) -> Any: ...
            def __format__(self, *args, **kwargs) -> Any: ...
            def __ge__(self, other) -> bool: ...
            def __getnewargs__(self, *args, **kwargs) -> Any: ...
            def __gt__(self, other) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> Any: ...
            def __int__(self) -> int: ...
            def __invert__(self) -> Any: ...
            def __le__(self, other) -> bool: ...
            def __lshift__(self, other) -> Any: ...
            def __lt__(self, other) -> bool: ...
            def __mod__(self, other) -> Any: ...
            def __mul__(self, other) -> Any: ...
            def __ne__(self, other) -> bool: ...
            def __neg__(self) -> Any: ...
            def __or__(self, other) -> Any: ...
            def __pos__(self) -> Any: ...
            def __pow__(self, other) -> Any: ...
            def __radd__(self, other) -> Any: ...
            def __rand__(self, other) -> Any: ...
            def __rdivmod__(self, other) -> Any: ...
            def __rfloordiv__(self, other) -> Any: ...
            def __rlshift__(self, other) -> Any: ...
            def __rmod__(self, other) -> Any: ...
            def __rmul__(self, other) -> Any: ...
            def __ror__(self, other) -> Any: ...
            def __round__(self) -> Any: ...
            def __rpow__(self, other) -> Any: ...
            def __rrshift__(self, other) -> Any: ...
            def __rshift__(self, other) -> Any: ...
            def __rsub__(self, other) -> Any: ...
            def __rtruediv__(self, other) -> Any: ...
            def __rxor__(self, other) -> Any: ...
            def __sizeof__(self) -> int: ...
            def __sub__(self, other) -> Any: ...
            def __truediv__(self, other) -> Any: ...
            def __trunc__(self) -> int: ...
            def __xor__(self, other) -> Any: ...
        __new__: ClassVar[function] = ...
        _generate_next_value_: ClassVar[function] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _value2member_map_: ClassVar[dict] = ...
        all_body: ClassVar[Utils.MergeMode] = ...
        only_root: ClassVar[Utils.MergeMode] = ...

    class SliceChangeMode(enum.IntEnum):
        class _member_type_:
            denominator: Any
            imag: Any
            numerator: Any
            real: Any
            @classmethod
            def __init__(cls, *args, **kwargs) -> None: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            @overload
            def as_integer_ratio(self) -> Any: ...
            def bit_count(self) -> Any: ...
            def bit_length(self) -> Any: ...
            def conjugate(self, *args, **kwargs) -> Any: ...
            @classmethod
            def from_bytes(cls, *args, **kwargs) -> Any: ...
            def to_bytes(self, *args, **kwargs) -> Any: ...
            def __abs__(self) -> Any: ...
            def __add__(self, other) -> Any: ...
            def __and__(self, other) -> Any: ...
            def __bool__(self) -> bool: ...
            def __ceil__(self, *args, **kwargs) -> int: ...
            def __divmod__(self, other) -> Any: ...
            def __eq__(self, other) -> bool: ...
            def __float__(self) -> float: ...
            def __floor__(self, *args, **kwargs) -> int: ...
            def __floordiv__(self, other) -> Any: ...
            def __format__(self, *args, **kwargs) -> Any: ...
            def __ge__(self, other) -> bool: ...
            def __getnewargs__(self, *args, **kwargs) -> Any: ...
            def __gt__(self, other) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> Any: ...
            def __int__(self) -> int: ...
            def __invert__(self) -> Any: ...
            def __le__(self, other) -> bool: ...
            def __lshift__(self, other) -> Any: ...
            def __lt__(self, other) -> bool: ...
            def __mod__(self, other) -> Any: ...
            def __mul__(self, other) -> Any: ...
            def __ne__(self, other) -> bool: ...
            def __neg__(self) -> Any: ...
            def __or__(self, other) -> Any: ...
            def __pos__(self) -> Any: ...
            def __pow__(self, other) -> Any: ...
            def __radd__(self, other) -> Any: ...
            def __rand__(self, other) -> Any: ...
            def __rdivmod__(self, other) -> Any: ...
            def __rfloordiv__(self, other) -> Any: ...
            def __rlshift__(self, other) -> Any: ...
            def __rmod__(self, other) -> Any: ...
            def __rmul__(self, other) -> Any: ...
            def __ror__(self, other) -> Any: ...
            def __round__(self) -> Any: ...
            def __rpow__(self, other) -> Any: ...
            def __rrshift__(self, other) -> Any: ...
            def __rshift__(self, other) -> Any: ...
            def __rsub__(self, other) -> Any: ...
            def __rtruediv__(self, other) -> Any: ...
            def __rxor__(self, other) -> Any: ...
            def __sizeof__(self) -> int: ...
            def __sub__(self, other) -> Any: ...
            def __truediv__(self, other) -> Any: ...
            def __trunc__(self) -> int: ...
            def __xor__(self, other) -> Any: ...
        __new__: ClassVar[function] = ...
        _generate_next_value_: ClassVar[function] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _value2member_map_: ClassVar[dict] = ...
        behind: ClassVar[Utils.SliceChangeMode] = ...
        front: ClassVar[Utils.SliceChangeMode] = ...
    def smooth_motion_data(self, bvh: pymotionlib.MotionData.MotionData, smooth_type: Union[Common.SmoothOperator.GaussianBase,Common.SmoothOperator.ButterWorthBase], test_out_fname: Optional[str] = ..., smooth_position: bool = ..., smooth_rotation: bool = ...) -> Any: ...

class World:
    __hash__: ClassVar[None] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    AngularDamping: Any
    AutoDisableAngularThreshold: Any
    AutoDisableFlag: Any
    AutoDisableLinearThreshold: Any
    AutoDisableSteps: Any
    AutoDisableTime: Any
    CFM: Any
    ContactMaxCorrectingVel: Any
    ContactSurfaceLayer: Any
    ERP: Any
    LinearDamping: Any
    NumBody: Any
    NumJoints: Any
    QuickStepNumIterations: Any
    max_contact_num: Any
    self_collision: Any
    soft_cfm: Any
    soft_erp: Any
    use_max_force_contact: Any
    use_soft_contact: Any
    @classmethod
    def __init__(cls) -> Any: ...
    def addBodyForce(self, ndarraynp_id, ndarraynp_force) -> Any: ...
    def addBodyTorque(self, ndarraynp_id, ndarraynp_tor) -> Any: ...
    def add_global_torque(self, ndarrayglobal_torque, ndarrayparent_body_id, ndarraychild_body_id) -> Any: ...
    def bodyListToNumpy(self, listbody_list) -> Any: ...
    def compute_body_com(self, ndarraynp_id) -> Any: ...
    def createBallJoint(self, jointgroup = ...) -> Any: ...
    def createBody(self) -> Any: ...
    def createContactJoint(self, jointgroup, contact) -> Any: ...
    def createContactJointMaxForce(self, jointgroup, contact) -> Any: ...
    def createFixedJoint(self, jointgroup = ...) -> Any: ...
    def createHinge2Joint(self, jointgroup = ...) -> Any: ...
    def createHingeJoint(self, jointgroup = ...) -> Any: ...
    def createSliderJoint(self, jointgroup = ...) -> Any: ...
    def dampedStep(self, dRealstepsize) -> Any: ...
    def damped_step_fast_collision(self, SpaceBasespace, dRealstepsize) -> Any: ...
    def destroy_immediate(self) -> Any: ...
    def getAllBodyID(self) -> np.ndarray: ...
    def getAllBodyInfos(self) -> Any: ...
    @overload
    def getAngularDamping(self) -> dReal: ...
    @overload
    def getAngularDamping(self) -> float: ...
    def getBallAndHingeAnchor1(self, ndarraynp_id) -> Any: ...
    def getBallAndHingeAnchor2(self, ndarraynp_id) -> Any: ...
    def getBallAndHingeAnchorAvg(self, ndarraynp_id) -> Any: ...
    def getBallAndHingeInfos(self) -> Any: ...
    def getBallAndHingeRawAnchor(self, ndarraynp_id) -> Any: ...
    def getBallAndHingeRawAnchor1(self, ndarraynp_id) -> Any: ...
    def getBallAndHingeRawAnchor2(self, ndarraynp_id) -> Any: ...
    def getBodyAngVel(self, ndarraynp_id) -> Any: ...
    def getBodyForce(self, ndarraynp_id) -> Any: ...
    def getBodyGeomCount(self, ndarraynp_id) -> int: ...
    def getBodyGeomIDs(self, ndarraynp_id) -> np.ndarray: ...
    def getBodyInertia(self, ndarraynp_id) -> Any: ...
    def getBodyInertiaInv(self, ndarraynp_id) -> Any: ...
    def getBodyInfos(self, ndarraynp_id) -> Any: ...
    def getBodyLinVel(self, ndarraynp_id) -> Any: ...
    def getBodyPos(self, ndarraynp_id) -> Any: ...
    def getBodyQuatScipy(self, ndarraynp_id) -> Any: ...
    def getBodyRot(self, ndarraynp_id) -> Any: ...
    def getBodyTorque(self, ndarraynp_id) -> Any: ...
    def getGravity(self) -> Any: ...
    def getGravityNumpy(self) -> np.ndarray: ...
    @overload
    def getLinearDamping(self) -> dReal: ...
    @overload
    def getLinearDamping(self) -> float: ...
    def getNumBallAndHingeJoints(self) -> Any: ...
    def get_all_hinge_angle(self, ndarrayhinge_id) -> Any: ...
    def get_all_joint_local_angle(self, ndarrayjoint_id) -> Any: ...
    def get_pd_control_torque(self, ndarrayjoint_id, ndarraylocal_target_quat_in: np.ndarray, ndarraykps_in: np.ndarray, ndarraytor_lim_in: np.ndarray) -> Any: ...
    def get_wid(self) -> Any: ...
    def impulseToForce(self, dRealstepsize, impulse) -> Any: ...
    def jointListToNumpy(self, listjoint_list) -> Any: ...
    def loadBodyAngVel(self, ndarraynp_id, ndarraynp_ang_vel) -> Any: ...
    def loadBodyForce(self, ndarraynp_id, ndarraynp_force) -> Any: ...
    def loadBodyInfos(self, ndarraynp_id, ndarraynp_pos, ndarraynp_quat, ndarraynp_rot, ndarraynp_lin_vel, ndarraynp_ang_vel, ndarraynp_force, ndarraynp_torque) -> Any: ...
    def loadBodyLinVel(self, ndarraynp_id, ndarraynp_lin_vel) -> Any: ...
    def loadBodyPos(self, ndarraynp_id, ndarraynp_pos) -> Any: ...
    def loadBodyQuat(self, ndarraynp_id, ndarraynp_quat) -> Any: ...
    def loadBodyQuatAndRotNoNorm(self, ndarraynp_id, ndarraynp_quat, ndarraynp_rot) -> Any: ...
    def loadBodyTorque(self, ndarraynp_id, ndarraynp_torque) -> Any: ...
    @overload
    def quickStep(self, dRealstepsize) -> Any: ...
    @overload
    def quickStep(self, stepsize) -> Any: ...
    @overload
    def setAngularDamping(self, dRealscale) -> Any: ...
    @overload
    def setAngularDamping(self, scale) -> Any: ...
    @overload
    def setGravity(self, gravity) -> Any: ...
    @overload
    def setGravity(self, gravity) -> Any: ...
    def setGravityYEarth(self) -> Any: ...
    @overload
    def setLinearDamping(self, dRealscale) -> Any: ...
    @overload
    def setLinearDamping(self, scale) -> Any: ...
    @overload
    def step(self, dRealstepsize) -> Any: ...
    @overload
    def step(self, stepsize) -> Any: ...
    def step_fast_collision(self, SpaceBasespace, dRealstepsize) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class _GeomAttrs:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class _SpaceIterator2:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __iter__(self) -> Any: ...
    def __next__(self) -> Any: ...
    def __reduce__(self) -> Any: ...
    def __setstate__(self, state) -> Any: ...

class interp1d(scipy.interpolate._polyint._Interpolator1D):
    __init__: ClassVar[function] = ...
    _call_linear: ClassVar[function] = ...
    _call_linear_np: ClassVar[function] = ...
    _call_nan_spline: ClassVar[function] = ...
    _call_nearest: ClassVar[function] = ...
    _call_previousnext: ClassVar[function] = ...
    _call_spline: ClassVar[function] = ...
    _check_and_update_bounds_error_for_extrapolation: ClassVar[function] = ...
    _check_bounds: ClassVar[function] = ...
    _evaluate: ClassVar[function] = ...
    fill_value: Any

class np_size_t(numpy.unsignedinteger):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    @overload
    def bit_count(self) -> int: ...
    @overload
    def bit_count(self) -> Any: ...
    def __abs__(self) -> Any: ...
    def __add__(self, other) -> Any: ...
    def __and__(self, other) -> Any: ...
    def __bool__(self) -> bool: ...
    @classmethod
    def __class_getitem__(cls, *args, **kwargs) -> Any: ...
    def __divmod__(self, other) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, other) -> Any: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> Any: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> Any: ...
    def __le__(self, other) -> bool: ...
    def __lshift__(self, other) -> Any: ...
    def __lt__(self, other) -> bool: ...
    def __mod__(self, other) -> Any: ...
    def __mul__(self, other) -> Any: ...
    def __ne__(self, other) -> bool: ...
    def __neg__(self) -> Any: ...
    def __or__(self, other) -> Any: ...
    def __pos__(self) -> Any: ...
    def __pow__(self, other) -> Any: ...
    def __radd__(self, other) -> Any: ...
    def __rand__(self, other) -> Any: ...
    def __rdivmod__(self, other) -> Any: ...
    def __rfloordiv__(self, other) -> Any: ...
    def __rlshift__(self, other) -> Any: ...
    def __rmod__(self, other) -> Any: ...
    def __rmul__(self, other) -> Any: ...
    def __ror__(self, other) -> Any: ...
    def __rpow__(self, other) -> Any: ...
    def __rrshift__(self, other) -> Any: ...
    def __rshift__(self, other) -> Any: ...
    def __rsub__(self, other) -> Any: ...
    def __rtruediv__(self, other) -> Any: ...
    def __rxor__(self, other) -> Any: ...
    def __sub__(self, other) -> Any: ...
    def __truediv__(self, other) -> Any: ...
    def __xor__(self, other) -> Any: ...

class pymotionlib:
    class BVHLoader:
        def load(self, unicodefn: str, insert_T_pose: bool = ..., ignore_root_offset = ..., max_frames = ..., ignore_root_xz_pos = ...) -> Any: ...
        def load_from_io(self, f, fn = ..., insert_T_pose: bool = ..., ignore_root_offset = ..., max_frames = ..., ignore_root_xz_pos = ...) -> Any: ...
        def load_from_string(self, unicodebvh_str: str, insert_T_pose: bool = ..., ignore_root_offset = ..., max_frames = ..., ignore_root_xz_pos = ...) -> Any: ...
        def save(self, data, unicodefn: str, unicodefmt: str = ..., unicodeeuler_order: str = ..., translational_joints = ..., insert_T_pose: bool = ...) -> Any: ...
        def save_as_string(self, data, unicodefmt: str = ..., unicodeeuler_order: str = ..., translational_joints = ..., insert_T_pose: bool = ...) -> Any: ...
        def save_to_io(self, data, f, unicodefmt: str = ..., unicodeeuler_order: str = ..., translational_joints = ..., insert_T_pose: bool = ...) -> Any: ...

    class ExtEndSite:
        def load_no_end_site(self, f: IO, ignore_root_offset = ..., max_frames = ...) -> Any: ...
        def save_ext_end_site(self, data, f: IO, unicodefmt: str = ..., unicodeeuler_order: str = ..., ext_end_site: Optional[Dict[int,np.ndarray]] = ...) -> Any: ...

    class MotionData:
        class MotionData:
            __slots__: ClassVar[tuple] = ...
            _end_sites: Any
            _fps: Any
            _joint_orientation: Any
            _joint_position: Any
            _joint_rotation: Any
            _joint_translation: Any
            _num_frames: Any
            _num_joints: Any
            _skeleton_joint_offsets: Any
            _skeleton_joint_parents: Any
            _skeleton_joints: Any
            def __init__(self) -> None: ...
            def align_joint_rotation_representation(self) -> Any: ...
            def append(self, other_) -> Any: ...
            def append_trans_rotation(self, ndarraytrans: np.ndarray, ndarrayrotation: np.ndarray) -> Any: ...
            def compute_angular_velocity(self, forward: bool = ...) -> Any: ...
            def compute_joint_global_info(self, ndarrayjoint_translation: np.ndarray, ndarrayjoint_rotation: np.ndarray, ndarrayjoint_position: np.ndarray = ..., ndarrayjoint_orientation: np.ndarray = ...) -> Any: ...
            def compute_joint_local_info(self, ndarrayjoint_position: np.ndarray, ndarrayjoint_orientation: np.ndarray, ndarrayjoint_translation: np.ndarray = ..., ndarrayjoint_rotation: np.ndarray = ...) -> Any: ...
            def compute_linear_velocity(self, forward: bool = ...) -> Any: ...
            def compute_rotational_speed(self, forward: bool) -> Any: ...
            def compute_translational_speed(self, forward: bool) -> Any: ...
            def flip(self, plane_of_symmetry_normal: Union[List[float],np.ndarray], mirror_joint_indices: Union[None,List[int]] = ...) -> Any: ...
            def get_adj_matrix(self) -> np.ndarray: ...
            def get_end_flags(self) -> np.ndarray: ...
            def get_hierarchy(self, copy: bool = ...) -> Any: ...
            def get_mirror_joint_indices(self) -> Any: ...
            def get_neighbours(self) -> List[List[int]]: ...
            def get_reference_pose(self) -> Any: ...
            def get_t_pose(self) -> Any: ...
            def re_root(self, new_root) -> Any: ...
            def recompute_joint_global_info(self) -> Any: ...
            def reconfig_reference_pose(self, rotations: Union[List[np.ndarray],np.ndarray,Dict[str,np.ndarray]], treat_as_global_orientations: bool, treat_as_reverse_rotation: bool) -> Any: ...
            def remore_reference_nodes(self, new_root) -> Any: ...
            def remove_end_sites(self, copy: bool = ...) -> Any: ...
            def remove_root_pos(self) -> Any: ...
            def resample(self, new_fps: int) -> Any: ...
            def reset_global_info(self) -> Any: ...
            def retarget(self, joint_map: Dict[str,Union[str,List[str]]]) -> Any: ...
            def scale(self, doublefactor: float) -> Any: ...
            def set_anim_attrs(self, num_frames, fps) -> Any: ...
            def sub_sequence(self, start: Optional[int] = ..., end: Optional[int] = ..., skip: Optional[int] = ..., copy: bool = ...) -> Any: ...
            def symmetrize_skeleton(self, plane_of_symmetry_normal: Union[List[float],np.ndarray], mirror_joint_indices: Union[None,List[int]]) -> Any: ...
            def to_contiguous(self) -> Any: ...
            def to_facing_coordinate(self) -> Any: ...
            def to_local_coordinate(self) -> Any: ...
            def z_up_to_y_up(self) -> Any: ...
            @property
            def end_sites(self) -> Optional[List[int]]: ...
            @property
            def fps(self) -> Any: ...
            @property
            def joint_names(self) -> Optional[List[str]]: ...
            @property
            def joint_offsets(self) -> Any: ...
            @property
            def joint_orientation(self) -> Optional[np.ndarray]: ...
            @property
            def joint_parents_idx(self) -> Any: ...
            @property
            def joint_position(self) -> Optional[np.ndarray]: ...
            @property
            def joint_rotation(self) -> Optional[np.ndarray]: ...
            @property
            def joint_translation(self) -> Optional[np.ndarray]: ...
            @property
            def num_frames(self) -> int: ...
            @property
            def num_joints(self) -> int: ...

    class MotionHelper:
        def adjust_root_height(self, data, dh: Optional[float] = ...) -> Any: ...
        def calc_children(self, data) -> Any: ...
        def calc_name_idx(self, data) -> Dict[str,int]: ...

    class Utils:
        def align_angles(self, ndarraya: np.ndarray, degrees: bool, inplace: bool) -> Any: ...
        def align_quaternion(self, ndarrayqt: np.ndarray, inplace: bool) -> Any: ...
        def animate_motion_data(self, data, show_skeleton = ..., show_animation = ..., interval = ...) -> Any: ...
        def flip_quaternion(self, ndarrayqt: np.ndarray, ndarraynormal: np.ndarray, inplace: bool) -> Any: ...
        def flip_vector(self, ndarrayvt: np.ndarray, ndarraynormal: np.ndarray, inplace: bool) -> Any: ...
        def get_joint_color(self, names, left = ..., right = ..., otherwise = ...) -> Any: ...
        def quat_product(self, ndarrayp: np.ndarray, ndarrayq: np.ndarray, inv_p: bool = ..., inv_q: bool = ...) -> Any: ...

@overload
def CloseODE() -> Any: ...
@overload
def CloseODE() -> Any: ...
@overload
def InitODE() -> Any: ...
@overload
def InitODE() -> Any: ...
def SetInitSeed(intvalue) -> Any: ...
@overload
def Space(intspace_type = ...) -> SpaceBase: ...
@overload
def Space(space_type = ...) -> Any: ...
@overload
def Space(space_type = ...) -> Any: ...
def __pyx_unpickle_GeomTypes(__pyx_type, long__pyx_checksum, __pyx_state) -> Any: ...
def __pyx_unpickle_JointParam(__pyx_type, long__pyx_checksum, __pyx_state) -> Any: ...
def __pyx_unpickle_JointTypes(__pyx_type, long__pyx_checksum, __pyx_state) -> Any: ...
@overload
def areConnected(Bodybody1, Bodybody2) -> bool: ...
@overload
def areConnected(body1, body2) -> bool: ...
@overload
def collide(GeomObjectgeom1, GeomObjectgeom2, intcontact_count = ...) -> list: ...
@overload
def collide(geom1, geom2) -> contacts: ...
@overload
def collide2(GeomObjectgeom1, GeomObjectgeom2, arg, callback) -> Any: ...
@overload
def collide2(geom1, geom2, arg, callback) -> Any: ...
def decompose_rotation_fast(ndarrayq, ndarrayvb) -> Any: ...
def decompose_rotation_pair_one2many_fast(ndarrayq, ndarrayvb) -> Any: ...
def decompose_rotation_single_fast(ndarrayq, ndarrayvb) -> Any: ...
def decompose_rotation_single_pair_fast(ndarrayq, ndarrayvb) -> Any: ...
def flip_quat_by_w_fast(ndarrayq) -> Any: ...
def mix_quat_by_slerp(ndarrayquat_input) -> Any: ...
def parent_child_quat_to_hinge_angle_fast(ndarrayquat0, ndarrayquat1, ndarrayinit_rel_quat_inv, ndarrayaxis) -> Any: ...
def quat_apply_forward_fast(ndarrayq, ndarrayv) -> Any: ...
def quat_apply_forward_one2many_fast(ndarrayq, ndarrayv) -> Any: ...
def quat_apply_single_fast(ndarrayq, ndarrayv) -> Any: ...
def quat_from_matrix_fast(ndarraymat) -> Any: ...
def quat_from_matrix_single_fast(ndarraymat) -> Any: ...
def quat_from_rotvec_fast(ndarrayx) -> Any: ...
def quat_from_rotvec_single_fast(ndarrayx) -> Any: ...
def quat_integrate_fast(ndarrayq, ndarrayomega, doubledt) -> Any: ...
def quat_inv_fast(ndarrayq1_) -> Any: ...
def quat_inv_single_fast(ndarrayq1_) -> Any: ...
def quat_multiply_forward_fast(ndarrayq1_, ndarrayq2_) -> Any: ...
def quat_multiply_forward_one2many_fast(ndarrayq1_, ndarrayq2_) -> Any: ...
def quat_multiply_forward_single(ndarrayq1_, ndarrayq2_) -> Any: ...
def quat_to_hinge_angle_fast(ndarrayq, ndarrayaxis) -> Any: ...
def quat_to_matrix_fast(ndarrayq) -> Any: ...
def quat_to_matrix_single_fast(ndarrayq) -> Any: ...
def quat_to_rotvec_fast(ndarrayq) -> Any: ...
def quat_to_rotvec_fast2(ndarrayq) -> Any: ...
def quat_to_rotvec_single_fast(ndarrayq) -> Any: ...
def quat_to_vec6d_fast(ndarrayq) -> Any: ...
def quat_to_vec6d_single_fast(ndarrayq) -> Any: ...
def simple_mix_quaternion(ndarrayquat_input, ndarrayweight_input = ...) -> Any: ...
def six_dim_mat_to_quat_fast(ndarraymat) -> Any: ...
def solve_lcp(intm, ndarraya, ndarrayb, intnub, ndarraylo, ndarrayhi, ndarrayfindex) -> Any: ...
def surface_distance_capsule(ndarrayrelative_distance, doubleradius, doublelength) -> Any: ...
def test_py_list_str_to_std_vector_str(lista) -> Any: ...
def vector_normalize_single_fast(ndarrayx) -> Any: ...
def vector_to_cross_matrix_fast(ndarrayvec) -> Any: ...
def visDrawBackground(x) -> Any: ...
def visDrawWorld() -> Any: ...
def visEndRecordVideo() -> Any: ...
def visGetScreenBuffer() -> Any: ...
def visGetWorld() -> Any: ...
def visKill() -> Any: ...
def visLookAt(pos, target, up) -> Any: ...
def visPause(time) -> Any: ...
def visSetAxisLength(x) -> Any: ...
def visSetColor(col) -> Any: ...
def visSetJointRadius(x) -> Any: ...
def visSetWorld(WorlddsWorld) -> Any: ...
def visStartRecordVideo() -> Any: ...
def visTrackBody(BodydsBody, track_character, sync_y) -> Any: ...
def visWhetherHingeAxis(x) -> Any: ...
def visWhetherLocalAxis(x) -> Any: ...
